#+title: GNU Emacs configuration
#+author: Troy Brumley
#+email: BlameTroi@gmail.com
#+language: en
#+options: ':t toc:nil num:t author:t email:t
#+startup: content indent
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

#+begin_center
       This a first pass at reducing Protesilaos' comprehensive
       literate configuration down to something I can work with
       to merge with my own pre-literate configuration. See his
         original at https://github.com/protesilaos/dotfiles.

        There are some renames in here to match my style, some
      partially merged stuff from my config, and some deletions
            of things I won't (or don't know how to) use.

           I'm keeping this around for reference. My actual
                 configuration is in 'literator.org'.
#+end_center

/This is my literate Emacs configuration file.
There are many like it, but this one is mine./

Protesilaos has clearly forgotten more about Emacs that I will
ever know. His knowledge is encyclopedic, his ability to share
that knowledge is excellent.

I stole this from Protesilaos' literate configuration to use as a
template for building my own. In addition to being very readable,
he uses a better tangling approach than I first learned. It's
certainly safer!

His dotfiles are all on GitHub at
https://github.com/protesilaos/dotfiles/tree/master. Given their
availability and his extensive explanations on YouTube and his
own website, I'm cutting large swaths of explanatory text out of
this as I try to wrestle it down into something I can use.

My Org usecases are trivial and I don't write serious prose.

Comments and surrounding text should make it clear when this has
been done. I have changed all his =prot= function and file
prefixes to =troi= to avoid confusion (mine) but I do not claim
that code.

I make a serious effort to mark direct quotes as such.

*If it's clever, new, or exceptionally well written, you
can bet Protesilaos wrote it*

/So let it be written./
/So let it be done./

*Last revised and exported on {{{latest-export-date}}} with a word
count of {{{word-count}}}.*

The idea here is to really do 'literate programming' and
+compile+ tangle this only when needed.

Evaluate the following to +compile+ tangle this into a new set of
configuration files.

#+begin_src emacs-lisp :tangle no :results none

;; evaluate this or use C-c C-v t
(org-babel-tangle)

#+end_src

You can find the original inspiration for this at:

+ Website: <https://protesilaos.com/emacs/dotemacs>


* The early initialisation of Emacs (=early-init.el=)
:PROPERTIES:
:CUSTOM_ID: h:7b7b5898-09f7-4128-8af0-4041f67cb729
:END:

Somewhere around Emacs 28 the initialization was split into two
distinct files. The =test-early-init= file includes some
initialization specific performance boosts and sets some other
things that are best done before Emacs launches its first frame.

The =test-early-init= file should contain no code that relies on
external files or packages or an established Emacs frame.


** The =early-init.el= basic frame settings
:PROPERTIES:
:CUSTOM_ID: h:a1288a07-93f6-4e14-894e-707d5ad8b6dc
:END:

These are some general settings for frames visuals. Unlike some
people I leave the menu bar enabled. On a Mac the space for the
menu isn't returned to you if you hide the menu, so I just hide
it. Having the menu available is a good idea given my lack of
familiarity with all the tools in Emacs.

First come a bunch of option settings that can be done here as
well as anywhere else. I'm trying to use `setopt' for
customizable variables. I had been using `setopt' instead of
`setq' for everything but that is a lazy approach.

I am only running Emacs on one system, a Mac, but if this is used
on other systems I'll need to do the appropriate checks.

#+begin_src emacs-lisp :tangle "bad-early-init.el"
;;; early-init.el --- troy brumley's early-init  -*- no-byte-compile: t; lexical-binding: t; -*-

;;; Commentary:

;; This file is generated from an Org document.

;;; Code:

(setopt frame-inhibit-implied-resize t)

(setopt frame-resize-pixelwise t)
(setopt window-resize-pixelwise t)
(setopt initial-frame-alist '((fullscreen . fullboth)
			      (ns-appearance . dark)
			      (ns-transparent-titlebar . t)))
(setopt default-frame-alist '((fullscreen . fullboth)
                              (ns-appearance . dark)
                              (ns-transparent-titlebar . t)))
(setopt use-dialog-box nil)
(setopt use-file-dialog nil)
(setopt use-short-answers t)
(setopt inhibit-splash-screen t)
(setopt inhibit-startup-screen t)
(setq inhibit-x-resources t)       ; x includes windows registry and ns here
(setopt inhibit-startup-echo-area-message user-login-name)
(setopt inhibit-startup-buffer-menu t)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8-unix)
(setopt confirm-kill-processes nil)		; Stop confirming the killing of processes

;; I leave the menu bar active but hidden.

(menu-bar-mode)        ; it's tucked out of the way in macos
(setopt ns-auto-hide-menu-bar t)
(scroll-bar-mode -1)
(tool-bar-mode -1)

#+end_src


** The =early-init.el= tweaks to startup time and garbage collection
:PROPERTIES:
:CUSTOM_ID: h:50d28f3c-3ada-4db5-b830-bbbbee7fec4e
:END:

These speed things up by minimizing garbage collection pauses and
turning off file handlers during startup. See
`file-name-handler-alist` for more details. These are restored
once startup is complete in `emacs-startup-hook'. I also remove
all the ~vs-handled-backends~ except ~Git~.

Any VCS that you use during =init.el= needs to be in
`vc-handled-backends'.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(setopt gc-cons-threshold most-positive-fixnum)
(setopt gc-cons-percentage 1.0)

(defvar troi/emacs--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(defvar troi/emacs--vc-handled-backends vc-handled-backends)
(setopt vc-handled-backends '(Git))

#+end_src

This is probably no longer useful on modern systems, but having
Emacs do a garbage collection if I leave Emacs couldn't hurt.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(defun troi/gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))

#+end_src

The `emacs-startup-hook' runs after =init.el= and is a good place
to restore handlers and garbage collection settings while also
setting the hook for garbage collection on focus change.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(add-hook 'emacs-startup-hook
          (lambda ()
            (setopt gc-cons-threshold (* 1024 1024 8))
            (setopt gc-cons-percentage 0.2)
            (setq   file-name-handler-alist troi/emacs--file-name-handler-alist)
	    (message "gc-cons-threshold & file-name-handler-alist restored")
	    (when (boundp 'after-focus-change-function)
	      (add-function
               :after after-focus-change-function
               #'troi/gc-after-focus-change))))

#+end_src


** The =early-init.el= touchpad and keyboard settings

I find touchpads to be a real pain. I keep brushing them which
leads to unwanted scrolling or selecting. Purcell's
`disable-mouse-mode' doesn't do what I want. I came up this
rather heavy handed (but working) way to stop the Mac touchpad
from moving things on me. The goal here is to prevent my
ham-fisted taps and brushes of the touchpad from moving stuff
around. I have mixed feelings about drag-the-scrollbar mouse
scrolling, but I don't like the mouse wheel in text editing.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(defun troi/bad-mouse-stop-that ()
  "Disable the mouse/touchpad.
This function aggressively swats mouse/touchpad in an attempt to prevent
the Mac trackpad from causing motion when I inevitably brush it. I am
setting it twice, both in `emacs-startup-hook' and `after-init-hook'
because I know of at least one package that needs `mouse-wheel-mode'
turned off during init and because something during init has overwritten
my `wheel-down' override."
  (global-set-key [wheel-up] 'ignore)
  (global-set-key [double-wheel-up] 'ignore)
  (global-set-key [triple-wheel-up] 'ignore)
  (global-set-key [wheel-down] 'ignore)
  (global-set-key [double-wheel-down] 'ignore)
  (global-set-key [triple-wheel-down] 'ignore)
  (global-set-key [wheel-left] 'ignore)
  (global-set-key [double-wheel-left] 'ignore)
  (global-set-key [triple-wheel-left] 'ignore)
  (global-set-key [wheel-right] 'ignore)
  (global-set-key [double-wheel-right] 'ignore)
  (global-set-key [triple-wheel-right] 'ignore)
  (mouse-wheel-mode -1)
  (message "trackpad stuff set to ignore"))

#+end_src

Originally I added the only invoked the function from
`emacs-startup-hook'. I later discovered that
`pixel-scroll-precision-mode' overwrites a few wheel/button
combinations, but not all of them. This regardless of
`mouse-wheel-mode'.

This led to mouse scrolling being partially on in Org when using
`visual-fill-column-mode'.

On chance that something during =init.el= might do something
similar to this, I also add the function to the
`after-init-hook'.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(add-to-list
 'emacs-startup-hook #'troi/bad-mouse-stop-that)
(add-to-list
 'after-init-hook #'troi/bad-mouse-stop-that)

#+end_src

And even after all of the above, the touchpad still responds to
some accidental contact. The best solution I've found so far is
to banish the mouse pointer to the lower right corner of my
display, moved up a bit so it doesn't trigger the Mac start bar.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(mouse-avoidance-mode 'banish)
(setopt mouse-avoidance-banish-position
	'((frame-or-window . frame) (side . right) (side-pos . 1)
	  (top-or-bottom . bottom) (top-or-bottom-pos . 15)))

#+end_src

The Mac keyboard layout is annoyingly different from a PC
keyboard layout, and neither layout matches those that influenced
the design of Emacs.

Changing <CAPS LOCK> to be <CONTROL> in OS settings is something
I do automatically on any system.

Emacs has the ability to remap keys itself (see Customization
Group `Ns') but I prefer doing that outside of Emacs.

The bottom row of a 'standard' keyboard holds all the keys that
might need remapping. Using 'Karbiner' I have remapped them as
follows:

| Original | Remapped             |
|----------+----------------------|
| fn       | control              |
| control  | fn                   |
| option   | command (ie., super) |
| command  | alt                  |
| spacebar | unchanged            |
| command  | unchanged            |
| ooption  | unchanged            |
|----------+----------------------|


** The =early-init.el= concludes with additional tweaks

This is a good place to turn off several warnings that are of no
real use to me. Byte compiling and Native Compiling either work
or they don't.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

;; TODO: return setopt on `byte-compile-warnings' after determining
;; the correct options.
(setq byte-compile-warnings '(not obsolete))
(setq warning-suppress-log-types '((comp) (bytecomp)))
(setopt native-comp-async-report-warnings-errors 'silent)

#+end_src

Enable native compilation if it is available. My current build
(emacs-plus@31) doesn't support native compilation yet, but when
it does this will turn it on.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(if (and (fboundp 'native-compile-available-p)
         (native-compile-available-p))
    (setopt package-native-compile t)
  (setq native-comp-async-report-warnings-errors 'silent) ; Emacs 28 with native compilation
  (setq native-compile-prune-cache t)) ; Emacs 29

#+end_src

One last optimization is to increate the size of the interprocess
communications buffer. Its default of 4K is ridiculously low. It
is not clear how large it can be, but this setting works.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

;; This improves performance of `eshell' based commands.
(setq read-process-output-max (* 4 1024 1024))

#+end_src

Finally, I don't like the way the Emacs Easy Customization writes
into the =init.el= file. Thankfully we can direct customizations
to a separate file parallel to the init.

The customization UI is a great tool for exploring and testing
options, and useful changes can be persisted to the custom file.

I don't load those customizations. I do review them and pull
anything useful into my hand crafted configuration.

#+begin_src emacs-lisp :tangle "bad-early-init.el"

(setopt custom-file (concat user-emacs-directory "i_dont_load_my_custom.el"))
;; (load custom-file) ; Oh no you don't!

(provide 'early-init)
;;; early-init.el ends here

#+end_src


* The main initialisation of Emacs (=init.el=)
:PROPERTIES:
:CUSTOM_ID: h:dae63bd9-93a8-41c4-af1b-d0f39ba50974
:END:

This is where I define the Lisp macros used in my setup and load
all the invidiual modules.


** The =init.el= preamble and some metadata

Start off with the proper file heading, set some metadata about
me, and issue required Emacs version warnings if needed.

#+begin_src emacs-lisp :tangle "bad-init.el"
;;; init.el --- troy brumley's init.el -*- no-byte-compile: t; lexical-binding: t; -*-

;;; Commentary:

;; This `init.el' file was generated from an Org document.

;;; Code:

;; I don't move my init around to foreign systems that don't have
;; current emacs builds, and I always run with the gui.

(when (< emacs-major-version 29)
  (error "This configuration requires Emacs 29 or newer!")
  (sleep-for 5))

(when (not (display-graphic-p))
  (message "This configuration assumes you are running a GUI Emacs, some things may break.")
  (sleep-for 5))

;; I don't see a natural place to put these, so I'll go with early.

(setopt user-full-name "Troy Brumley")
(setopt user-mail-address "BlameTroi@gmail.com")
(setopt auth-sources '("~/.authinfo.gpg"))
(setopt auth-source-cache-expiry nil)

#+end_src


** The =init.el= settings to enable certain commands and disable others
:PROPERTIES:
:CUSTOM_ID: h:4ed6593f-6f55-4258-a1c2-ddb50e9e2465
:END:

Emacs has training wheels. I don't want training wheels. We use
`put` instead of `setopt` because these are attributes and not
free standing variables.

#+begin_src emacs-lisp :tangle "bad-init.el"

;; Enable these
(mapc
 (lambda (command)
   (put command 'disabled nil))
 '(list-timers narrow-to-region narrow-to-page narrow-to-defun upcase-region downcase-region overwrite-mode))

;; And disable these
(mapc
 (lambda (command)
   (put command 'disabled t))
 '(iconify-frame)) ;; removed overwrite-mode iconify-frame eshell project-eshell

#+end_src


** The =init.el= setting to always start with the =*scratch*= buffer
:PROPERTIES:
:CUSTOM_ID: h:96878899-f712-4900-8ee1-de8c40a634ce
:END:

I'm currently using the scratch buffer as my starting point. If I
start using Org agenda heavily enough, I will investigate
dashboard options.

#+begin_src emacs-lisp :tangle "bad-init.el"

(setopt initial-buffer-choice t)
(setopt initial-major-mode 'lisp-interaction-mode)
(setopt initial-scratch-message
      (format ";; This is `%s'.  Use `%s' to evaluate and print results.\n\n"
              'lisp-interaction-mode
              (propertize
               (substitute-command-keys "\\<lisp-interaction-mode-map>\\[eval-print-last-sexp]")
               'face 'help-key-binding)))

#+end_src


** The =init.el= arrangements for my own modules and custom libraries
:PROPERTIES:
:CUSTOM_ID: h:e289a614-4f17-4d6c-a028-42fe45aebe66
:END:

Break the tangled configuration into separate files. It's a
rational approach. I like the idea of separate files for
debugging and categorization, but I only want one file for
editing. Add two directories to the load-path. Each with a
different purpose.

- The =bad-emacs-modules= directory :: This is where the source
  code blocks land during tangling. The naming is by logical
  functional grouping, for example: such as ~bad-emacs-font~,
  ~bad-emacs-window~. These are intended only for configuration
  purposes. They should not define any major variables or
  functions if at all possible.

- The =troi-lisp= directory :: One off things I've written or in
  development (new or maintenance) packages. Several of
  Protesilaos' custom libraries land here as well. I have a TODO:
  to move them.

#+begin_src emacs-lisp :tangle "bad-init.el"

(mapc
 (lambda (string)
   (add-to-list 'load-path (locate-user-emacs-file string)))
 '("troi-lisp" "bad-emacs-modules"))

#+end_src


** The =init.el= settings for packages (=package.el=)
:PROPERTIES:
:CUSTOM_ID: h:424340cc-f3d7-4083-93c9-d852d40dfd40
:END:

Set up package repositories and assign their priority order.

#+begin_src emacs-lisp :tangle "bad-init.el"

;; Packages

;; I'm not sure what this does so I'm clipping it for now.
;; (setq package-vc-register-as-project nil) ; Emacs 30
;; But remember that Git should be a valid VCS handler.

(add-hook 'package-menu-mode-hook #'hl-line-mode)

;; This avoids some odd errors I was seeing in `use-package'.
;; It may not be needed anymore.

(eval-when-compile
  (require 'use-package))
;;(require 'diminish)       ; if you use :diminish
;;(require 'bind-key)       ; if you use any :bind variant
(setopt load-prefer-newer t)

;; Set up use-package and repoistories.

(with-eval-after-load 'package
  (defvar package-archives)
  (add-to-list
   'package-archives
   '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list
   'package-archives
   '("melpa" . "https://melpa.org/packages/") t)
  (setopt package-archive-priorities
          '(("gnu" . 10)
            ("nongnu" . 9)
            ("melpa-stable" . 6)
            ("melpa" . 5))))

#+end_src


** The =init.el= configuration of `no-littering'

The `no-littering' package attempts to reduce the clutter of
`user-emacs-directory' by coercing various packages to use
subdirectories `etc/' and `var/'. This needs to come as early as
possible in =init.el= and so I put it immediately after `package'
and `use-package' are established.

There is a full migration guide (that I have not read yet) at
<https://github.com/emacscollective/no-littering/> but just
adding this and deleting some stragglers I don't care about has
been helpful.

#+begin_src emacs-lisp :tangle "bad-init.el"

;; NOTE: Yes, the two `require' calls in that order are deliberate and
;; they seem to work. Without them, not so much.

(use-package no-littering
  :ensure t
  :init
  (require 'no-littering)
  (require 'recentf)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude no-littering-etc-directory))

(use-package recentf
  :ensure nil
  :custom
  (recentf-max-menu-items 100)
  (recentf-max-saved-items 100)
  :config
  (recentf-mode))

#+end_src

In the 21st Century computers and file systems are pretty
reliable. And then there's the /Cloud/. Lockfiles don't make
sense for me since I'm always on a single user system.

#+begin_src emacs-lisp :tangle "bad-init.el"

(setopt make-backup-files nil)
(setopt backup-inhibited nil) ; Is this redundant?
(setopt create-lockfiles nil)
(setopt auto-save-default nil)

#+end_src


** The =init.el= option to declare all themes as safe
:PROPERTIES:
:CUSTOM_ID: h:00213452-3671-4de6-b4ce-ca1b65f79413
:END:

I already know it's a risk, and I knew it before I started the
load.

#+begin_src emacs-lisp :tangle "bad-init.el"

(setq custom-safe-themes t)

#+end_src


** The =init.el= macro to do nothing with Elisp code (~bad-emacs-comment~)
:PROPERTIES:
:CUSTOM_ID: h:3b14faa6-83fd-4d5f-b3bc-85f72fd572d4
:END:

This is a neat trick...

#+BEGIN_QUOTE
This is something I learnt while studying Clojure: a ~comment~
macro that wraps some code, effectively commenting it out, while
keeping indentation and syntax highlighting intact.

What I have here is technically not commenting out the code,
because the expansion of the macro is nil, not the actual code
with comments around it.
#+END_QUOTe

#+begin_example emacs-lisp
(defmacro bad-emacs-comment (&rest body)
  "Do nothing with BODY and return nil, with no side effects."
  (declare (indent defun))
  nil)
#+end_example

#+BEGIN_QUOTE
The above is an example. What I actually use is the following. It
behaves the same as above, except when it reads a plist of the
form =(:eval t)=. The idea is for me to quickly activate
something I want to test by passing that to the macro. So here we
have it:
#+END_QUOTE

#+begin_src emacs-lisp :tangle "bad-init.el"

(defmacro bad-emacs-comment (&rest body)
  "Determine what to do with BODY.

If BODY contains an unquoted plist of the form (:eval t) then
return BODY inside a `progn'.

Otherwise, do nothing with BODY and return nil, with no side
effects."
  (declare (indent defun))
  (let ((eval))
    (dolist (element body)
      (when-let* (((plistp element))
                  (key (car element))
                  ((eq key :eval))
                  (val (cadr element)))
        (setq eval val
              body (delq element body))))
    (when eval `(progn ,@body))))

#+end_src

#+begin_src emacs-lisp :tangle "bad-init.el"

;; Sample use of `bad-emacs-comment'.  The function
;; `bad-emacs-insert-comment-macro' is never evaluated.

(bad-emacs-comment
  (defun bad-emacs-insert-comment-macro (beg end)
    "Wrap region between BEG and END in `bad-emacs-comment'."
    (interactive "r")
    (if (region-active-p)
        (let ((text (buffer-substring beg end)))
          (delete-region beg end)
          (insert (format "(bad-emacs-comment\n%s)" text))
          (indent-region beg end))
      (user-error "No active region; will not insert `bad-emacs-comment' here"))))

#+end_src


** The =init.el= macro to bind keys (~bad-emacs-keybind~) and other key bind helpers
:PROPERTIES:
:CUSTOM_ID: h:d3684ec0-a972-4033-a4d6-41ee16e891d9
:END:

I don't yet fully understand Emacs key binding, and this is yet
another way to manage them. I'm keeping Prot's macro in place
with his explanation:

#+begin_quote
This Lisp macro does not try to be too smart. It simply reduces
the typing we have to do to define key bindings. As with the
underlying ~define-key~ function, it can bind a key sequence to a
command, a nil value, or even a keymap. The constraint it imposes
is that the arguments supplied to it as an even number and the
odd ones are key bindings (strings that can be passed to the
~kbd~ function). This means that it does not try to cover the
case of =[remap COMMAND]= (I am not a fan of it because the code
alone does not tell us which key we end up using ([[#h:6b6778af-8bd2-4f97-a794-e23774aa6cf3][Why don't you
remap keys?]])).
#+end_quote

#+begin_src emacs-lisp :tangle "bad-init.el"

(defmacro bad-emacs-keybind (keymap &rest definitions)
  "Expand key binding DEFINITIONS for the given KEYMAP.
DEFINITIONS is a sequence of string and command pairs."
  (declare (indent 1))
  (unless (zerop (% (length definitions) 2))
    (error "Uneven number of key+command pairs"))
  (let ((keys (seq-filter #'stringp definitions))
        ;; We do accept nil as a definition: it unsets the given key.
        (commands (seq-remove #'stringp definitions)))
    `(when-let* (((keymapp ,keymap))
                 (map ,keymap))
       ,@(mapcar
          (lambda (pair)
            (let* ((key (car pair))
                   (command (cdr pair)))
              (unless (and (null key) (null command))
                `(define-key map (kbd ,key) ,command))))
          (cl-mapcar #'cons keys commands)))))

;; Sample of `bad-emacs-keybind'

;; (bad-emacs-keybind global-map
;;   "C-z" nil
;;   "C-x b" #'switch-to-buffer
;;   "C-x C-c" nil
;; ;; Notice the -map as I am binding keymap here, not a command:
;;   "C-c b" beframe-prefix-map
;;   "C-x k" #'kill-buffer)
#+end_src

This seems like a good place to grab `which-key' and other key
binding helpers. Oh, and `diminish' since I start using it
immediately.

Oh, and accidently dropped the section for this macro.

#+begin_src emacs-lisp :tangle "bad-init.el"
(defmacro bad-emacs-abbrev (table &rest definitions)
  "Expand abbrev DEFINITIONS for the given TABLE.
DEFINITIONS is a sequence of (i) string pairs mapping the
abbreviation to its expansion or (ii) a string and symbol pair
making an abbreviation to a function."
  (declare (indent 1))
  (unless (zerop (% (length definitions) 2))
    (error "Uneven number of key+command pairs"))
  `(if (abbrev-table-p ,table)
       (progn
         ,@(mapcar
            (lambda (pair)
              (let ((abbrev (nth 0 pair))
                    (expansion (nth 1 pair)))
                (if (stringp expansion)
                    `(define-abbrev ,table ,abbrev ,expansion)
                  `(define-abbrev ,table ,abbrev "" ,expansion))))
            (seq-split definitions 2)))
     (error "%s is not an abbrev table" ,table)))


#+end_src

#+begin_src emacs-lisp :tangle "bad-init.el"

(use-package diminish
  :ensure t)

(use-package free-keys
  :ensure t)

(use-package which-key
  :ensure nil
  :diminish
  :config (which-key-mode))

#+end_src


** The =init.el= addition of highlighting for my macros
:PROPERTIES:
:CUSTOM_ID: h:d168edaa-426f-4bd0-8275-3ec3d66bf126
:END:

Rose tint those macros...

#+begin_src emacs-lisp :tangle "bad-init.el"

(defvar bad-emacs-package-form-regexp
  "^(\\(bad-emacs-keybind\\|bad-emacs-abbrev\\) +'?\\([0-9a-zA-Z-]+\\)"
  "Regexp to add packages to `lisp-imenu-generic-expression'.")

(eval-after-load 'lisp-mode
  `(add-to-list 'lisp-imenu-generic-expression
                (list "Packages" ,bad-emacs-package-form-regexp 2)))

(defconst bad-emacs-font-lock-keywords
  '(("(\\(bad-emacs-\\(keybind\\|abbrev\\)\\)\\_>[ \t']*\\(\\(\\sw\\|\\s_\\)+\\)?"
     (3 font-lock-variable-name-face nil t))
    ("(\\(bad-emacs-comment\\)\\_>[ \t']*"
     (1 font-lock-preprocessor-face nil t))))

(font-lock-add-keywords 'emacs-lisp-mode bad-emacs-font-lock-keywords)

#+end_src


** The =init.el= make sure we have our environment variables!

This is primarily for MacOs where reading the shell environment
depends upon settings in the app's ~plist~ files.

A TODO: is to make this variable list customizable.

#+begin_src emacs-lisp :tangle "bad-init.el"

;; Sometimes a MacOs 'app' build of Emacs doesn't pull in shell
;; environment variables. I also believe that the build scripts have
;; hard coded variable lists.
;;
;; Enter `exec-path-from-shell'. It copies environment variables from
;; the shell into the Emacs process.
;;
;; This list isn't comprehensive. As I find a variable missing, I add
;; it to the list.

(use-package exec-path-from-shell
  :ensure t
  :config
  (declare-function
   exec-path-from-shell-initialize "exec-path-from-shell" ())
  (declare-function
   exec-path-from-shell-copy-envs "exec-path-from-shell")
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs
   '("LIBRARY_PATH"
     "INFOPATH"
     "CPATH"
     "MANPATH"
     "MallocNanoZone"               ;; silence some libc allocation warnings
     "CMAKE_GENERATOR"
     "CDPATH"
     "ODIN_ROOT")))

#+end_src


** My ~init.el~ catch all of things that didn't have a spot in Prot's layout

I have some applications and packages that weren't in the
original configuration. I'm trying to dump them all here, let's
see how it goes.

#+begin_src emacs-lisp :tangle "bad-init.el"
;; I don't like trailing spaces.

(use-package ws-butler
  :ensure t
  :diminish
  :hook (prog-mode . ws-butler-mode))

;; I don't know if this is covered by some of Prot's
;; other changes.

(use-package saveplace
  :ensure nil
  :config
  (save-place-mode)
  :custom
  (save-place-limit 1000))

;; I often use C-l for visual breaks.

(use-package form-feed-st
  :ensure t
  :diminish
  :hook
  (prog-mode . form-feed-st-mode)
  (text-mode . form-feed-st-mode))

;; I started out with `deft' and `side-notes' before I slid over
;; the edge and into the gravity well of `org'. I still use them
;; from time to time.

;; `deft' is a quick and easy note indexing system using plain
;; text. I keep these notes distinct from `org'.

(use-package deft
  :ensure t
  :config
  (setopt deft-directory
	  (expand-file-name "~/Notepad"))
  (setopt deft-text-mode (seq-find 'fboundp '(markdown-mode text-mode)))
  (setopt deft-extension
          (assoc-default deft-text-mode '((markdown-mode . "md") (rst-mode . "rst"))
			 'eq "txt")))

;; 'side-notes' lets you have notes files in any project or directory.
;; the notes are opened in a side window like 'imenu-list'. Searching
;; for the notes files are done backward up the the directory path
;; until one is found.
;;
;; I tend to keep these files out of git.

(use-package side-notes
  :ensure t
  :diminish
  :bind ("M-s n" . side-notes-toggle-notes)
  :custom
  (side-notes-file "side-notes.txt")
  (side-notes-secondary-file "~/general-side-notes.txt"))

;; Read documentation with 'info' and 'eldoc'. For some reason I'm
;; missing system info from homebrew. I should probably move this into
;; my `.zshenv'.

(use-package info
  :ensure nil
  :after exec-path-from-shell
  :custom
  (Info-additional-directory-list '("/opt/homebrew/share/info")))

;; This may be a useful addition, providing project navigation in a
;; sidebar.

(use-package treemacs
  :ensure t
  :after nerd-icons
  :bind
  (:map global-map
        ("M-0"       . treemacs-select-window)
        ("C-x t t"   . treemacs)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag)))

;; TODO: project-treemacs may be a useful add-on to treemacs

(use-package treemacs-nerd-icons
  :after treemacs
  :ensure t)

;; This provides a smoother scrolling experience, making the positioning of text
;; when point moves in and out of the visual display behave more like `vim'.
;;
;; Since I don't use the mouse/touchpad for scrolling, I'm not sure where I
;; picked up `pixel-scroll-precision-mode'. It resets several events that I
;; turn off to quiet the touchpad. I'm forcing it off even though I'm confused
;; at it causing problems since I clearly set the events to ignore in the
;; `after-init-hook'. In case it ever slips in again, I explicitly turn it
;; off here.

(setopt scroll-margin 0)
(setopt scroll-conservatively 100000)
(setopt scroll-preserve-screen-position 1)
(pixel-scroll-precision-mode -1)

;; Additional mode line information.

(column-number-mode)
(setopt mode-line-position-column-line-format '(" (%l,%C)")) ; %C based 1, %c based 0
(add-hook 'prog-mode-hook 'which-function-mode)

;; Odds and ends that I didn't see elsewhere.



(setopt sentence-end-double-space nil)
(setopt require-final-newline t)
(setopt js-indent-level 8) ; this might more properly be in programming languages
(setopt blink-matching-delay 0.1)
(setq apropos-sort-by-scores t)
(defalias 'yes-or-no-p 'y-or-n-p)
(setopt confirm-kill-emacs 'y-or-n-p)

;; I use 'astyle' to do formatting for C. See '.astylerc'. My style is
;; based on linux and k&r.

(use-package reformatter
  :ensure t
  :after exec-path-from-shell)

(use-package astyle
  :after reformatter
  :when (executable-find "astyle")
  :diminish (astyle-on-save-mode . "as")
  :hook
  (c-ts-mode . astyle-on-save-mode)
  (c++-ts-mode . astyle-on-save-mode))

;; I think of movement (of point) while typing and navigation aids
;; such as `xref' or `imenu' as all one thing, and for organization in
;; init I keep them with my global keybinds.

(use-package avy
  :ensure t
  :bind (("C-c j" . avy-goto-line)
         ("s-j"   . avy-goto-char-timer)))

(use-package ace-window
  :ensure t
  :bind (("C-x o" . ace-window)
	 ("M-o" . ace-window)))

;; 'Dumb-jump' is a dwim for 'xref'.
(use-package dumb-jump
  :hook
  (xref-backend-functions . dump-jump-xref-activate))

;; Programming Language Support.

;; Configure the 'clangd' language server to my preferences. 'Clangd'
;; will need 'CMakeLists.txt' and 'compile_commands.json' in each
;; project's root directory.

(with-eval-after-load 'eglot
  (add-to-list
   'eglot-server-programs
   '((c-ts-mode c++-ts-mode)
     . ("clangd"
        "-j=4"                   ; async index threads
	"--log=info"             ;"error" or "verbose"
	"--pch-storage=memory"   ; I have plenty
	"--enable-config"))))

;; Odin's lsp doesn't seem to need much configuration.

(require 'odin-mode)

(with-eval-after-load 'eglot
  (add-to-list
   'eglot-server-programs
   '(odin-mode . ("ols"))))

;; Other languages/modes as needed.

(use-package cmake-mode
  :ensure t)

(use-package ninja-mode
  :ensure t)

(use-package git-modes
  :ensure t)

;; `Flymake' has been a good linter interface. `Eglot' reports issues
;; from 'clang-tidy' through 'flymake'.

(use-package flymake
  :after exec-path-from-shell
  :hook			      ;;
  (c-ts-mode . flymake-mode)	      ;;
  (c++-ts-mode . flymake-mode)     ;;
  (emacs-lisp-mode . flymake-mode) ;;
  :custom (flymake-mode-line-lighter "FM")
  :bind (:map flymake-mode-map
	      ("M-n" . flymake-goto-next-error)
	      ("M-p" . flymake-goto-prev-error)
              ("C-c ! l" . flymake-show-buffer-diagnostics)
              ("C-c ! L" . flymake-show-project-diagnostics)))

;; This is needed to avoid false 'can not find/load' errors on
;; `requires' that occur before this point in the source.

(with-eval-after-load 'flymake
  (setopt elisp-flymake-byte-compile-load-path load-path))

;; auto-hide hides function bodies in some programming modes.

(use-package auto-hide
  :vc
  (auto-hide :url "https://github.com/ultronozm/auto-hide.el"
             :branch "main")
  :hook (c-ts-mode . hs-minor-mode)
  :config
  (global-auto-hide-mode))

;; `Treesitter' can be touchy about its abi due to the differing release cycles
;; of the two development groups. It is still worth using for language modes
;; that have a `ts' variant. The `treesit-auto' package can be used to build
;; grammars as needed.

(use-package treesit
  :ensure nil

  :custom
  (treesit-font-lock-level 4)           ; levels 1-3 are useless

  )

;; some of these might require M-x treesit-install-language-grammar
(setopt major-mode-remap-alist
	'((yaml-mode . yaml-ts-mode)
	  (bash-mode . bash-ts-mode)
	  (js-mode . js-ts-mode)
	  (typescript-mode . typescript-ts-mode)
	  (json-mode . json-ts-mode)
	  (c-mode . c-ts-mode)
	  (c++-mode . c++-ts-mode)
	  (c-or-c++-mode . c-or-c++-ts-mode)
	  (ruby-mode . ruby-ts-mode)))

(use-package ruby-ts-mode
  :ensure nil
  :mode "\\.rb\\'"
  :mode "Rakefile\\'"
  :mode "Gemfile\\'")

(use-package markdown-ts-mode
  :mode ("\\.md\\'" . markdown-ts-mode)
  :config
  (add-to-list
   'treesit-language-source-alist
   '(markdown
     "https://github.com/tree-sitter-grammars/tree-sitter-markdown"
     "split_parser"
     "tree-sitter-markdown/src"))
  (add-to-list
   'treesit-language-source-alist
   '(markdown-inline
     "https://github.com/tree-sitter-grammars/tree-sitter-markdown"
     "split_parser"
     "tree-sitter-markdown-inline/src")))

(use-package c-ts-mode
  :ensure nil

  :custom
  (c-ts-mode-indent-offset 8)           ; turns out I like tabs, who knew?
  (c-ts-mode-indent-style 'linux)

  :config
  (keymap-unset c-ts-base-mode-map "C-c C-c") ; redundant with M-;

  )

(use-package treesit-auto
  :ensure t
  :after exec-path-from-shell

  :custom
  (treesit-auto-install 'prompt)

  :config
  (declare-function treeset-auto-add-to-auto-mode-alist "treesit-auto" t t)
  (treesit-auto-add-to-auto-mode-alist
   '(bash
     c
     commonlisp
     cpp
     go
     html
     java
     javascript
     json
     make
     markdown
     org
     python
     ruby
     toml
     typescript
     yaml))
  (declare-function global-treesit-auto-mode "treesit-auto")
  (global-treesit-auto-mode))

;; Add 'kind of item' icons to marginalia notes and other parts of the
;; UI.

(use-package kind-icon
  :ensure t
  :if (display-graphic-p)
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

(add-to-list
 'prog-mode-hook #'turn-on-font-lock)


#+end_src


** The =init.el= final part to load the individual modules
:PROPERTIES:
:CUSTOM_ID: h:e6c4acf5-5b51-4b38-a86a-bf3f698ac872
:END:

The configuration is split into multiple files. Load the files
via `require` `provide`.

#+begin_src emacs-lisp :tangle "bad-init.el"
;; hilight cursor line

(let ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
  (mapc (lambda (hook) (add-hook hook 'hl-line-mode)) hl-line-hooks))

;; visual line mode is ok for text, use (truncate-lines t) for code.

(add-hook 'text-mode-hook 'visual-line-mode)


;; Protesilaos provides a hook point for those who just want to
;; set preferences before loading this configuration.
;;
;; I don't need this for my use and am removing them.

(require 'bad-emacs-theme)
(require 'bad-emacs-essentials)
(require 'bad-emacs-completion)
(require 'bad-emacs-search)
(require 'bad-emacs-dired)
(require 'bad-emacs-window)
(require 'bad-emacs-git)
(require 'bad-emacs-org)
(require 'bad-emacs-langs)
(require 'bad-emacs-icons)

(provide 'init)
#+end_src


* The modules of my Emacs configuration
:PROPERTIES:
:CUSTOM_ID: h:dc3e88c8-4def-4a3f-b63c-9e845b0f98ef
:END:

In =init.el= I have a section where I add my modules to the
~load-path~ so that Emacs can run their code. The subheadings of
this chapter define modules, each of which is loaded at the end
of =init.el=.


** The =bad-emacs-theme.el= module
:PROPERTIES:
:CUSTOM_ID: h:8cf67c82-1ebb-4be8-b0e7-161bbf5419ce
:END:

This was a very comprehensive selection of aestheics related
configuration. I have hard coded the theme and deleted or
commented out the things I don't feel a need for or sufficiently
understand.


*** The =bad-emacs-theme.el= section to load a theme (~bad-emacs-load-theme-family~)
:PROPERTIES:
:CUSTOM_ID: h:3f1a33e4-762e-4cf3-a0ae-4c2954d9cbb8
:END:

Pick a theme here. I follow Prot's convetion of separate theme
configuration modules but you have to hard code the ~require~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-theme.el" :mkdirp yes
  ;;; Theme setup and related

    (require 'bad-emacs-acme-theme)

#+end_src


**** The =bad-emacs-acme-theme.el= module

This is my preferred theme.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-acme-theme.el"

(use-package acme-theme
  :ensure t
  :config
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'acme t)
  (setopt acme-theme-black-fg t)
  (custom-set-faces
   '(hl-line ((t (
                  :inherit highlight
                  :extend t
                  :background "LightGoldenrod2"
                  :foreground "black"))))
   '(compilation-error ((t (:background "gray80" :foreground "Red"))))
   '(flymake-error ((t (:underline (:color "Red" :style wave :position nil)))))
   '(font-lock-comment-face ((t (:foreground "#707070" :slant oblique))))
   '(font-lock-comment-face ((t (:foreground "#005500" :slant oblique))))))

;; pulling out of custom.el to control here:
(set-face-attribute 'default nil :font "FiraCode Nerd Font Mono" :height 190)
(set-face-attribute 'fixed-pitch nil :font "FiraCode Nerd Font Mono" :height 190)
(set-face-attribute 'variable-pitch nil :font "Cantarell" :height 230 :weight 'medium)
;; Choose some fonts
;; (set-face-attribute 'default nil :family "Iosevka")
;; (set-face-attribute 'variable-pitch nil :family "Iosevka Aile")
(provide 'bad-emacs-acme-theme)
#+end_src


**** The =bad-emacs-deepblue-theme.el= module

The `tomorrow-night-deepblue-theme' is a beautiful throwback.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-deepblue-theme.el"

(use-package tomorrow-night-deepblue-theme
  :ensure t
  :pin melpa
  :config
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'tomorrow-night-deepblue t))
(provide 'bad-emacs-deepblue-theme)
#+end_src


*** The =bad-emacs-theme.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:bac0ce0a-db68-42e7-ba2c-f350f91f80ef
:END:

Finally, we ~provide~ the module. This is the mirror function of
~require~ ([[#h:e6c4acf5-5b51-4b38-a86a-bf3f698ac872][The init.el final part to load the individual
modules]]). This pattern repeats throughout.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-theme.el"

(provide 'bad-emacs-theme)

#+end_src


** The =bad-emacs-essentials.el= module
:PROPERTIES:
:CUSTOM_ID: h:0ef52ed9-7b86-4329-ae4e-eff9ab8d07f2
:END:

Tweak all the things. Prot has many custom libraries, I don't
know how many I will retain. I don't like to add too many things
I don't completely understand at one time.


*** The =bad-emacs-essentials.el= block with basic configurations
:PROPERTIES:
:CUSTOM_ID: h:713ede33-3802-40c6-a8e3-7e1fc0d0a924
:END:

I had many of these settings already. I am commenting out those I
don't yet want (like `delete-pair'). Settings that I bring in
that weren't here tend to be `setopt' instead of `setq' to help
me track them.

Also unbind or repurpose some of the default key bindings.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el" :mkdirp yes

;; Essential configurations

(use-package emacs
  :ensure nil
  :demand t
  :config
  (setq-default fill-column 65)
  (setq help-window-select t)
  (setopt help-window-keep-selected t)
  ;; (setq next-error-recenter '(4)) ; center of the window
  (setq find-library-include-other-files nil) ; Emacs 29
  (setq save-interprogram-paste-before-kill t)
  (setopt require-final-newline t) ;; how does this interact with mode-... below?
  (setq mode-require-final-newline 'visit-save)
  (setq-default truncate-partial-width-windows nil)
  (setq eval-expression-print-length nil)
  (setq kill-do-not-save-duplicates t)
  (setq scroll-error-top-bottom t)
  (setq epa-keys-select-method 'minibuffer) ; Emacs 30

  :bind
  ( :map global-map

    ("<insert>" . nil)
    ("<menu>" . nil)

    ("C-x C-v" . nil) ; never use it
    ("C-z" . nil) ; I have a window manager, thanks!
    ("C-x C-z" . nil) ; same idea as above
    ("C-x C-c" . nil) ; avoid accidentally exiting Emacs
    ;; ("C-x C-c C-c" . save-buffers-kill-emacs) ; more cumbersome, less error-prone
    ;; ("C-x C-r" . restart-emacs) ; override `find-file-read-only'
    ("C-h h" . nil) ; Never show that "hello" file
    ("M-`" . nil)

    ("M-SPC" . cycle-spacing)
    ("M-z" . zap-up-to-char) ; NOT `zap-to-char'
    ("M-c" . capitalize-dwim)
    ("M-l" . downcase-dwim) ; "lower" case
    ("M-u" . upcase-dwim)
    ("M-=" . count-words) ;; was count-words-region

    ("C-h K" . describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
    ("C-h u" . apropos-user-option)
    ("C-h F" . apropos-function) ; lower case is `describe-function'
    ("C-h V" . apropos-variable) ; lower case is `describe-variable'
    ("C-h L" . apropos-library) ; lower case is `view-lossage'
    ("C-h c" . describe-char) ; overrides `describe-key-briefly'

    ;; some of my globals
    ("<escape>" . keyboard-escape-quit)
    ("C-x C-d" . dired)
    ("C-x C-b" . ibuffer)
    ("C-s" . isearch-forward-regexp)
    ("C-r" . isearch-backward-regexp)

    :map prog-mode-map
    ;; ("C-M-d" . up-list) ; confusing name for what looks like "down" to me
    ;; ("<C-M-backspace>" . backward-kill-sexp)

    ;; Keymap for buffers (Emacs28)
    ;; :map ctl-x-x-map
    ;; ("f" . follow-mode)  ; override `font-lock-update'
    ;; ("r" . rename-uniquely)
    ;; ("l" . visual-line-mode)

    ))

#+end_src


*** The =bad-emacs-essentials.el= section about =troi-common.el= (custom basic functions)
:PROPERTIES:
:CUSTOM_ID: h:116854fa-2e31-4d23-ae6f-72f57ed571bc
:END:

#+begin_quote
[[#h:3fccfadf-22e9-457f-b9fd-ed1b48600d23][The =troi-common.el= library]] contains custom snippets that I use
in various other parts of my setup, notably my custom libraries
("packages"). All I do here is load it, so that others will have
it available by the time they need it.

Since the =troi-common.el= defines some basic functions that can
be used outside the narrow confines of my custom code, I set them
up here:

1. Truncate lines by default in a number of places and do not
   produce a message about the fact. Note that the function used
   to achieve this, i.e. ~troi-common-truncate-lines-silently~,
   may also be set up elsewhere and described in that context.
   Here I only cover the basic parent modes.
#+end_quote

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

(use-package troi-common
  :ensure nil
  :functions (troi-common-truncate-lines-silently)
  :hook ((fundamental-mode text-mode prog-mode dired-mode) . troi-common-truncate-lines-silently))

#+end_src


*** The =bad-emacs-essentials.el= section about =troi-simple.el= (custom basic commands)
:PROPERTIES:
:CUSTOM_ID: h:f15bc843-2dd1-4792-95ec-9b7b6e561804
:END:

Prot has a library of small simple commands that he binds to
various keys.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

(use-package troi-simple
  :ensure nil
  :demand t

  :bind
  ( ("ESC ESC" . troi-simple-keyboard-quit-dwim)
    ("C-g" . troi-simple-keyboard-quit-dwim)
;;    ("C-M-SPC" . troi-simple-mark-sexp)   ; will be overriden by `expreg' if tree-sitter is available
    ;; Commands for lines
    ;; ("M-k" . troi-simple-kill-line-backward)
    ;; ("M-j" . delete-indentation)
    ("M-w" . troi-simple-kill-ring-save)
    ("C-S-d" . troi-simple-duplicate-line-or-region)
    ;; ("C-S-w" . troi-simple-copy-line)
    ;; ("C-S-y" . troi-simple-yank-replace-line-or-region)
    ;; ("C-v" . troi-simple-multi-line-below) ; overrides `scroll-up-command'
    ;; ("<next>" . troi-simple-multi-line-below) ; overrides `scroll-up-command'
    ;; ("M-v" . troi-simple-multi-line-above) ; overrides `scroll-down-command'
    ;; ("<prior>" . troi-simple-multi-line-above) ; overrides `scroll-down-command'
    ;; ("<C-return>" . troi-simple-new-line-below)
    ;; ("<C-S-return>" . troi-simple-new-line-above)

    ;; the C-x x map is defined elsewhere but I
    ;; commented it out.
    ;; ("C-x x a" . troi-simple-auto-fill-visual-line-mode) ; auto-fill/visual-line toggle
    ;; Commands for text insertion or manipulation
    ;; ("C-=" . troi-simple-insert-date)
    ;; ("C-<" . troi-simple-escape-url-dwim)
    ;; "C->" troi-simple-insert-line-prefix-dwim
    ;; ("M-Z" . troi-simple-zap-to-char-backward)
    ;; Commands for object transposition
    ;; ("C-S-p" . troi-simple-move-above-dwim)
    ;; ("C-S-n" . troi-simple-move-below-dwim)
    ("C-t" . troi-simple-transpose-chars)
    ("C-x C-t" . troi-simple-transpose-lines)
    ("C-S-t" . troi-simple-transpose-paragraphs)
    ("C-x M-t" . troi-simple-transpose-sentences)
    ("C-M-t" . troi-simple-transpose-sexps)
    ("M-t" . troi-simple-transpose-words)
    ;; Commands for paragraphs
    ("M-Q" . troi-simple-unfill-region-or-paragraph)
    ;; Commands for windows and pages
    ;; ("C-x o" . troi-simple-other-window)
    ;; ("C-x n k" . troi-simple-delete-page-delimiters)
  ;;  ("C-x M-r" . troi-simple-swap-window-buffers)
    ;; Commands for buffers
    ;; ("<C-f2>" . troi-simple-rename-file-and-buffer)
    ("C-x k" . troi-simple-kill-buffer-current)
    ("C-x K" . kill-buffer) ; leaving this here to contrast with the above
    ("M-s b" . troi-simple-buffers-major-mode)
    ("M-s v" . troi-simple-buffers-vc-root)
    ;; Commands for files
    ("C-x r ." . troi-simple-file-to-register)))

#+end_src


*** The =bad-emacs-essentials.el= section about =troi-scratch.el= (scratch buffer per major mode)
:PROPERTIES:
:CUSTOM_ID: h:45b4fffa-2ce3-4119-b8c9-081a75135d98
:END:

Create a scratch buffer for a given major mode, copy an active
region into that buffer, and set the buffer's mode.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; Scratch buffers per major mode (troi-scratch.el)
(use-package troi-scratch
  :ensure nil
  :bind ("C-c s" . troi-scratch-buffer)
  :config
  (setq troi-scratch-default-mode 'text-mode))

#+end_src


*** The =bad-emacs-essentials.el= section about =troi-prefix.el= (prefix nested keymaps)
:PROPERTIES:
:CUSTOM_ID: h:15ad94b3-f714-4b39-973e-b68c76b38be3
:END:

See Prot's video:

[ Watch: [[https://protesilaos.com/codelog/2024-01-29-emacs-prefix-map/][define prefix/leader key (nested key maps)]] (2024-01-29). ]

A tool to redefine key maps into a series of sequences starting
with a mnemonic (<b>uffer, <w>indow, etc).

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

  ;; Prefix keymap (troi-prefix.el)

  (use-package troi-prefix
    :ensure nil
    :bind-keymap
    (("<insert>" . troi-prefix)
     ("C-z" . troi-prefix)))

#+end_src


*** The =bad-emacs-essentials.el= settings for bookmarks
:PROPERTIES:
:CUSTOM_ID: h:581aa0ff-b136-4099-a321-3b86edbfbccb
:END:

Make sure bookmarks are persisted immediately.

Bookmarks are registers. At least that's how they seem to be
presented to me.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; Built-in bookmarking framework (bookmark.el)
(use-package bookmark
  :ensure nil
  :commands (bookmark-set bookmark-jump bookmark-bmenu-list)
  :hook (bookmark-bmenu-mode . hl-line-mode)
  :config
  ;; (setq bookmark-fringe-mark nil) ; Emacs 29 to hide bookmark fringe icon
  ;; Write changes to the bookmark file as soon as 1 modification is
  ;; made (addition or deletion).  Otherwise Emacs will only save the
  ;; bookmarks when it closes, which may never happen properly
  ;; (e.g. power failure).
  (setq bookmark-save-flag 1))

#+end_src


*** The =bad-emacs-essentials.el= settings for registers
:PROPERTIES:
:CUSTOM_ID: h:5685df62-4484-42ad-a062-d55ab19022e3
:END:

[ Watch: [[https://protesilaos.com/codelog/2023-06-28-emacs-mark-register-basics/][Mark and register basics]] (2023-06-28). ]

Akin to bookmarks, we have registers. I really need to use them
more instead of relying on the =kill-ring= for paste operations.
I also really need to learn to use keyboard macros.

Registers are not ordinarily persisted across sessions, but Prot
hooks them into =savehist=.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; Registers (register.el)
(use-package register
  :ensure nil
  :defer t ; its commands are autoloaded, so this will be loaded then
  :config
  (setq register-preview-delay 0.8
        register-preview-function #'register-preview-default)

  (with-eval-after-load 'savehist
    (add-to-list 'savehist-additional-variables 'register-alist)))

#+end_src


*** The =bad-emacs-essentials.el= settings for auto revert
:PROPERTIES:
:CUSTOM_ID: h:7753549e-806d-4140-b72d-5460a4a14b3e
:END:

I have mixed feelings about "auto revert" functionality, but I
could just be too old fashioned. The modern practice seems to be
to run with it enabled.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; Auto revert mode
(use-package autorevert
  :ensure nil
  :hook (after-init . global-auto-revert-mode)
  :config
  (setq auto-revert-verbose t))

#+end_src


*** The =bad-emacs-essentials.el= section for ~delete-selection-mode~
:PROPERTIES:
:CUSTOM_ID: h:d551b90d-d730-4eb5-976a-24b010fd4db3
:END:

Sometimes the old ways are wrong.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; Delete selection
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))

#+end_src


*** The =bad-emacs-essentials.el= settings for tooltips
:PROPERTIES:
:CUSTOM_ID: h:26afeb95-7920-45ed-8ff6-3648256c280b
:END:

With these settings in place, Emacs will use its own faces and
frame infrastructure to display tooltips.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

  ;; Tooltips (tooltip-mode)
  (use-package tooltip
    :ensure nil
    :hook (after-init . tooltip-mode)
    :config
    (setq tooltip-delay 0.5
          tooltip-short-delay 0.5
          ;; x-gtk-use-system-tooltips t -- I don't find an ns- equivalent
          tooltip-frame-parameters
          '((name . "tooltip")
            (internal-border-width . 10)
            (border-width . 0)
            (no-special-glyphs . t))))

#+end_src


*** The =bad-emacs-essentials.el= settings for manpages
:PROPERTIES:
:CUSTOM_ID: h:5eb16d63-ce21-4e76-8789-eef6ddbd7c00
:END:

Man page support seems to be behind the times and does not honor
display behavior options. This customization seems to bring it
into line.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

;; `man' (manpages)
(use-package man
  :ensure nil
  :commands (man)
  :config
  (setq Man-notify-method 'pushy)) ; does not obey `display-buffer-alist'

#+end_src


*** The =bad-emacs-essentials.el= arrangement to run Emacs as a server
:PROPERTIES:
:CUSTOM_ID: h:7709b7e9-844f-49f3-badf-784aacec4bca
:END:

I'm not sure this is something I will use, and getting a server
or daemon configuration on MacOs is reputedly difficult. I'll
leave this here but I am not using it (yet).

If I do start using this, I will need to read up on the ~server~
package and ~emacsclient~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"
;; Emacs server (allow emacsclient to connect to running session)

(use-package server
  :ensure nil
  :defer 1
  :config
  (setq server-client-instructions nil)
  ;;(unless (server-running-p)
  ;;  (server-start))
  (message "server not started")
  )

#+end_src


*** The =bad-emacs-essentials.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:c8b2f021-fe5a-4f6b-944c-20340f764fb2
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-essentials.el"

(provide 'bad-emacs-essentials)

#+end_src


** The =bad-emacs-completion.el= module
:PROPERTIES:
:CUSTOM_ID: h:15edf2c3-4419-4101-928a-6e224958a741
:END:

Completion is one of Emacs' super powers. They myriad of
completion frameworks (providers and presenters) is one of the
more confusing aspects of Emacs.


*** The =bad-emacs-completion.el= settings for completion styles
:PROPERTIES:
:CUSTOM_ID: h:14b09958-279e-4069-81e3-5a16c9b69892
:END:

The ~completion-styles~ are pattern matching algorithms. They
interpret user input and offer possible matches. Prot provides an
excellent explanation of the built in styles and ~orderless~.
I've been using ~prescient~ but have used ~orderless~ and other
options in the past.

I've reduced the style descriptions to a listing of the built in
styles and a brief description of what Prot does with
~orderless~.

- emacs22 :: Prefix completion that only operates on the text
  before point.

- basic :: Prefix completion that also accounts for the text after point.

- partial-completion :: This is used for file navigation. Instead
  of typing out a full path like =~/.local/share/fonts=, we do
  =~/.l/s/f= or variants thereof to make the matches unique.

- substring :: Matches the given sequence of characters literally
  regardless of where it is in word.

- flex :: Completion of an in-order subset of characters. It does
  not matter where the charactes are in the word, so long as they
  are encountered in the given order.

  (troi: this is the style I find most natural)

- initials :: Completion of acronyms and initialisms.

- orderless :: This is a separate package with more extensive
  configuration in another section. It matches patterns
  out-of-order. Patterns are typically space delimited words or
  regular expressions.

Prot uses all of the above styles in order, from strictest match
to broadest. Entering a blank force ~orderless~ completion as
none of the built-in styles parses a blank.

These styles can be overridden or augmented by specific
minibuffer prompts.

Instead of having to find and configure each possible completion
category (say file names vs elisp variables) Prot sets
~completion-category-defaults~ to nil, which will fall back to to
the global ~completion-styles~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el" :mkdirp yes

;; General minibuffer settings

(use-package minibuffer
  :ensure nil
  :config
;; Completion styles
  (setq completion-styles '(basic substring initials flex orderless)) ; also see `completion-category-overrides'
  (setq completion-pcm-leading-wildcard t) ; Emacs 31: make `partial-completion' behave like `substring'

  ;; Reset all the per-category defaults so that (i) we use the
  ;; standard `completion-styles' and (ii) can specify our own styles
  ;; in the `completion-category-overrides' without having to
  ;; explicitly override everything.
  (setq completion-category-defaults nil)

  ;; A non-exhaustve list of known completion categories:
  ;;
  ;; - `bookmark'
  ;; - `buffer'
  ;; - `charset'
  ;; - `coding-system'
  ;; - `color'
  ;; - `command' (e.g. `M-x')
  ;; - `customize-group'
  ;; - `environment-variable'
  ;; - `expression'
  ;; - `face'
  ;; - `file'
  ;; - `function' (the `describe-function' command bound to `C-h f')
  ;; - `info-menu'
  ;; - `imenu'
  ;; - `input-method'
  ;; - `kill-ring'
  ;; - `library'
  ;; - `minor-mode'
  ;; - `multi-category'
  ;; - `package'
  ;; - `project-file'
  ;; - `symbol' (the `describe-symbol' command bound to `C-h o')
  ;; - `theme'
  ;; - `unicode-name' (the `insert-char' command bound to `C-x 8 RET')
  ;; - `variable' (the `describe-variable' command bound to `C-h v')
  ;; - `consult-grep'
  ;; - `consult-isearch'
  ;; - `consult-kmacro'
  ;; - `consult-location'
  ;; - `embark-keybinding'
  ;;
  (setq completion-category-overrides
        ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
        ;; default for some contexts.  Read:
        ;; <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387>.
        ;;
        ;; `partial-completion' is a killer app for files, because it
        ;; can expand ~/.l/s/fo to ~/.local/share/fonts.
        ;;
        ;; If `basic' cannot match my current input, Emacs tries the
        ;; next completion style in the given order.  In other words,
        ;; `orderless' kicks in as soon as I input a space or one of its
        ;; style dispatcher characters.
        '((file (styles . (basic partial-completion orderless)))
          (bookmark (styles . (basic substring)))
          (library (styles . (basic substring)))
          (embark-keybinding (styles . (basic substring)))
          (imenu (styles . (basic substring orderless)))
          (consult-location (styles . (basic substring orderless)))
          (kill-ring (styles . (emacs22 orderless)))
          (eglot (styles . (emacs22 substring orderless))))))

#+end_src


*** The =bad-emacs-completion.el= for the ~orderless~ completion style
:PROPERTIES:
:CUSTOM_ID: h:7cc77fd0-8f98-4fc0-80be-48a758fcb6e2
:END:

The ~orderless~ package parses user input and interprets it
out-of-order, so that =in pa= will offer both ~insert-pair~ and
~package-install~.

~Orderless~ also has "style dispatchers". Attaching some
characters to input will caue ~orderless~ to use a specific
pattern for a component.

We can also define so-called "style dispatchers". These are
characters attached to the input which instruct ~orderless~ to
use a specific pattern for that component. =troi-orderless.el=
defines these as postfix operators.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

;; Orderless completion style (and troi-orderless.el)
(use-package orderless
  :ensure t
  :demand t
  :after minibuffer
  :config
  ;; Remember to check my `completion-styles' and the
  ;; `completion-category-overrides'.
  (setq orderless-matching-styles '(orderless-prefixes orderless-regexp))

  ;; SPC should never complete: use it for `orderless' groups.
  ;; The `?' is a regexp construct.
  :bind ( :map minibuffer-local-completion-map
          ("SPC" . nil)
          ("?" . nil)))

(use-package troi-orderless
  :ensure nil
  :config
  (setq orderless-style-dispatchers
        '(troi-orderless-literal
          troi-orderless-file-ext
          troi-orderless-beg-or-end)))

#+end_src


*** The =bad-emacs-completion.el= settings to ignore letter casing
:PROPERTIES:
:CUSTOM_ID: h:7fe1787d-dba3-46fe-82a9-5dc5f8ea6217
:END:

I almost never care about letter case in searches.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(setq completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
(setq-default case-fold-search t)   ; For general regexp
(setq read-file-name-completion-ignore-case t)

#+end_src


*** The =bad-emacs-completion.el= settings for recursive minibuffers
:PROPERTIES:
:CUSTOM_ID: h:4299825a-db51-49fe-b415-fb1749eed289
:END:

You don't know you need recursive minibuffers until you need
recursive minibuffers. I've had them enabled since forever.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(use-package mb-depth
  :ensure nil
  :hook (after-init . minibuffer-depth-indicate-mode)
  :config
  ;; (setq read-minibuffer-restore-windows t) ; Emacs 28, Prot uses nil
  (setq enable-recursive-minibuffers t))

#+end_src


*** The =bad-emacs-completion.el= settings for default values
:PROPERTIES:
:CUSTOM_ID: h:aebbdd4c-6e5b-4773-9f0a-c69f0d3c7158
:END:

Adjust the visuals of minibuffer prompts for default values.

The ~minibuffer-electric-default-mode~ displays the default value
next to the prompt only if =RET= will actually use the default.
So when you start typing in the minibuffer, the
=[some-default-value]= indicator disappears.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(use-package minibuf-eldef
  :ensure nil
  :hook (after-init . minibuffer-electric-default-mode)
  :config
  (setq minibuffer-default-prompt-format " [%s]")) ; Emacs 29

#+end_src


*** The =bad-emacs-completion.el= settings for common interactions
:PROPERTIES:
:CUSTOM_ID: h:b640f032-ad11-413e-ad8f-63408671d500
:END:

Several small minibuffer tweaks.

- The need to ~resize-mini-windows~ arises on some occasions
  where Emacs has to show text spanning multiple lines in the
  "mini windows"

- The ~read-answer-short~ is complementary to
  ~use-short-answers~.

- The ~echo-keystrokes~ is set to a low value to show what is
  being typed in the echo area.

- The ~minibuffer-prompt-properties~ and advice to
  ~completing-read-multiple~ make it so that (i) the minibuffer
  prompt is not accessible with regular motions to avoid mistakes
  and (ii) prompts that complete multiple targets show an
  indicator about this fact.

- Finally the ~file-name-shadow-mode~ is a neat little feature to
  remove the "shadowed" part of a file prompt while using
  something like =C-x C-f= (=M-x find-file=). File name shadowing
  happens when we invoke ~find-file~ and instead of first
  deleting the contents of the minibuffer, we start typing out
  the file system path we wish to visit.

  I may want to turn this off. We'll see.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(use-package rfn-eshadow
  :ensure nil
  :hook (minibuffer-setup . cursor-intangible-mode)
  :config
  ;; Not everything here comes from rfn-eshadow.el, but this is fine.

  (setq resize-mini-windows t)
  (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
  (setq echo-keystrokes 0.25)
  (setq kill-ring-max 60) ; Keep it small

  ;; Do not allow the cursor to move inside the minibuffer prompt.  I
  ;; got this from the documentation of Daniel Mendler's Vertico
  ;; package: <https://github.com/minad/vertico>.
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  ;; MCT has a variant of this built-in.
  ;; i don't use mct, this should be updated

    ;; Add prompt indicator to `completing-read-multiple'.  We display
    ;; [`completing-read-multiple': <separator>], e.g.,
    ;; [`completing-read-multiple': ,] if the separator is a comma.  This
    ;; is adapted from the README of the `vertico' package by Daniel
    ;; Mendler.  I made some small tweaks to propertize the segments of
    ;; the prompt.
    (defun crm-indicator (args)
      (cons (format "[`completing-read-multiple': %s]  %s"
                    (propertize
                     (replace-regexp-in-string
                      "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                      crm-separator)
                     'face 'error)
                    (car args))
            (cdr args)))

    (advice-add #'completing-read-multiple :filter-args #'crm-indicator))

  (file-name-shadow-mode 1)

#+end_src


*** The =bad-emacs-completion.el= generic minibuffer UI settings
:PROPERTIES:
:CUSTOM_ID: h:de61a607-0bdf-462b-94cd-c0898319590e
:END:

These are some settings for the default completion user
interface.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(use-package minibuffer
  :ensure nil
  :demand t
  :config
  (setq completions-format 'one-column)
  (setq completion-show-help nil)
  (setq completion-auto-help 'always)
  (setq completion-auto-select nil)
  ;; my config has completion-auto-select t, and
  ;; at some point it was 'second-tab
  (setq completions-detailed t)
  (setq completion-show-inline-help nil)
  (setq completions-max-height 6)
  (setq completions-header-format (propertize "%s candidates:\n" 'face 'bold-italic))
  (setq completions-highlight-face 'completions-highlight)
  (setq minibuffer-completion-auto-choose t)
  (setq minibuffer-visible-completions t) ; Emacs 30
  (setq completions-sort 'historical)

  ;; (unless bad-emacs-completion-ui
  ;;   (bad-emacs-keybind minibuffer-local-completion-map
  ;;     "<up>" #'minibuffer-previous-line-completion
  ;;     "<down>" #'minibuffer-next-line-completion)
  ;;   (add-hook 'completion-list-mode-hook #'troi-common-truncate-lines-silently))
  )

#+end_src


*** The =bad-emacs-completion.el= settings for saving the history (~savehist-mode~)
:PROPERTIES:
:CUSTOM_ID: h:25765797-27a5-431e-8aa4-cc890a6a913a
:END:

Many parts of Emacs have distinct histories, others are mingled.
These are not persisted by default, but can be added to
~savehist-additional-variables~. Initialize ~savehist~ here, and
some other sections may add to ~savehist-additional-variables~.

Note that the user option ~history-length~ applies to each
history variable.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

;; `savehist' (minibuffer and related histories)
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode)
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 100)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-to-list 'savehist-additional-variables 'kill-ring)
  (add-to-list 'savehist-additional-variables 'compile-command)
  (add-to-list 'savehist-additional-variables 'regexp-search-ring)
  )

#+end_src


*** The =bad-emacs-completion.el= settings for dynamic text expansion (~dabbrev~)
:PROPERTIES:
:CUSTOM_ID: h:567bb00f-1d82-4746-93e5-e0f60721728a
:END:

Emacs has both "dynamic" and static text expansion. In "dabbrev"
we configure the dynamic abbreviation support. By dynamic we mean
"in the current context." ~dabbrev~ can look for matches
throughout the current Emacs session.

I do not make enough use of these sorts of completions or
expansions. Hopefully I will learn enough from this literate
configuration adventure to start seeing opportunities to use
them.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

(use-package dabbrev
  :ensure nil
  :commands (dabbrev-expand dabbrev-completion)
  :config
;; `dabbrev' (dynamic word completion (dynamic abbreviations))
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (setq dabbrev-ignored-buffer-modes
        '(archive-mode image-mode docview-mode pdf-view-mode)))

#+end_src


*** The =bad-emacs-completion.el= settings for static text expansion (~abbrev~)
:PROPERTIES:
:CUSTOM_ID: h:fd84b79a-351e-40f0-b383-bf520d77834b
:END:

[ Watch: [[https://protesilaos.com/codelog/2024-02-03-emacs-abbrev-mode/][abbreviations with abbrev-mode (quick text expansion)]] (2024-02-03). ]

These are configurable expansions. I am viewing them like macros,
but that is an incorrect analogy.

Abbreviations are strings of characters are replaced when they
are entered. Example, Prot's =meweb= expands to the url of his
home page.

The command ~unexpand-abbrev~ is available to undo an expansion
if needed.

Each major mode has its own abbrev table. There is also a
~global-abbrev-table~. A modes table takes precedence over the
global table. Modes that inherit from other modes (Org from text,
C from prog) inherit those abbreviation tables.

Prot's abbreviation macro (here named ~bad-emacs-abbrev~) makes
it easier to define abbreviations.

The original list of abbreviations was comprehensive but specific
to Prot's useage. On the first pass through this I am deleting
things that I won't obviously use. Later I hope to actually add
some abbreviations of my own.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

;; `abbrev' (Abbreviations, else Abbrevs)
(use-package abbrev
  :ensure nil
  ;; message-mode derives from text-mode, so we don't need a separate
  ;; hook for it.
  :hook ((text-mode prog-mode git-commit-mode) . abbrev-mode)
  :config
  (setq only-global-abbrevs nil)

  (bad-emacs-abbrev global-abbrev-table
    "megit"   "https://github.com/blametroi"
    "mehub"   "https://github.com/blametroi"
    "meclone" "git@github.com/blametroi/"
    ";git"   "https://github.com/blametroi"
    ";hub"   "https://github.com/blametroi"
    ";clone" "git@github.com/blametroi/"
    )

  (bad-emacs-abbrev text-mode-abbrev-table
    "asciidoc"       "AsciiDoc"
    "cafe"           "caf"
    "cliche"         "clich"
    "github"         "GitHub"
    "gitlab"         "GitLab"
    "javascript"     "JavaScript"
    "latex"          "LaTeX"
    "libreplanet"    "LibrePlanet"
    "paypal"         "PayPal"
    "typescript"     "TypeScript"
    "visavis"        "vis--vis"
    "deja"           "dj"
    "youtube"        "YouTube"
    ";up"            ""
    ";uni"           ""
    ";laugh"         ""
    ";smile"         ""
    ";sun"           "")

  ;; Allow abbrevs with a prefix colon, semicolon, or underscore.  See:
  ;;  <https://protesilaos.com/codelog/2024-02-03-emacs-abbrev-mode/>.
  (abbrev-table-put global-abbrev-table :regexp "\\(?:^\\|[\t\s]+\\)\\(?1:[:;_].*\\|.*\\)")

  (with-eval-after-load 'text-mode
    (abbrev-table-put text-mode-abbrev-table :regexp "\\(?:^\\|[\t\s]+\\)\\(?1:[:;_].*\\|.*\\)"))

  (with-eval-after-load 'org
    (bad-emacs-abbrev org-mode-abbrev-table
      ";dev" "{{{development-version}}}")
    (abbrev-table-put org-mode-abbrev-table :regexp "\\(?:^\\|[\t\s]+\\)\\(?1:[:;_].*\\|.*\\)"))

  (with-eval-after-load 'message
    (bad-emacs-abbrev message-mode-abbrev-table
      "i-need-to" "hook-up-mail")
    )

  ;; The `bad-emacs-abbrev' macro, which simplifies how we use
  ;; `define-abbrev', does not only expand a static text.  It can take
  ;; a pair of string and function to trigger the latter when the
  ;; former is inserted.  Think of it like the basis of a simplistic
  ;; templating system.
  (require 'troi-abbrev)
  (bad-emacs-abbrev global-abbrev-table
    "metime" #'troi-abbrev-current-time
    "medate" #'troi-abbrev-current-date
    ";time" #'troi-abbrev-current-time
    ";date" #'troi-abbrev-current-date
    )

  (bad-emacs-abbrev text-mode-abbrev-table
    ";update" #'troi-abbrev-update-html)

  ;; Because the *scratch* buffer is produced before we load this, we
  ;; have to explicitly activate the mode there.
  (when-let* ((scratch (get-buffer "*scratch*")))
    (with-current-buffer scratch
      (abbrev-mode 1)))

  ;; By default, abbrev asks for confirmation on whether to use
  ;; `abbrev-file-name' to save abbrevations.  I do not need that, nor
  ;; do I want it.
  (remove-hook 'save-some-buffers-functions #'abbrev--possibly-save))

#+end_src


*** The =bad-emacs-completion.el= for in-buffer completion popup (~corfu~)
:PROPERTIES:
:CUSTOM_ID: h:804b858f-7913-47ef-aaf4-8eef5b59ecb4
:END:

Prot uses ~corfu~, which I am already using. Hopefully the merge
of settings will go smoothly.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

;; Corfu (COmpletion in Region FUnctions, in-buffer completion popup)
(use-package corfu
  :ensure t
  :if (display-graphic-p)
  :hook (after-init . global-corfu-mode)
  ;; I also have (setq tab-always-indent 'complete) for TAB to complete
  ;; when it does not need to perform an indentation change.
  :bind (:map corfu-map ("<tab>" . corfu-complete))
  :config
  (setq corfu-preview-current nil)
  (setq corfu-min-width 20)

  (setq corfu-popupinfo-delay '(0.25 . 0.1))
  (setq corfu-popupinfo-hide nil)
  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'

  ;; Sort by input history (no need to modify `corfu-sort-function').
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history))
  ;; Additions ... not making these, just documenting some differences

  ;; :bind
  ;; (:map corfu-map
  ;;       ("SPC" . corfu-insert-separator)
  ;;      ("C-n" . corfu-next)
  ;;      ("C-p" . corfu-previous))
  ;; :hook ((prog-mode . corfu-mode)
  ;;       (shell-mode . corfu-mode)
  ;;       (eshell-mode . corfu-mode))
  ;;:custom
  ;; hide commands in m-x which do not apply to the current mode.
  ;; (read-extended-command-predicate #'command-completion-default-include-p)
  ;; disable ispell completion function. as an alternative try `cape-dict'.
  ;; (text-mode-ispell-word-completion nil)

  )

#+end_src


*** The =bad-emacs-completion.el= settings for ~consult~
:PROPERTIES:
:CUSTOM_ID: h:22e97b4c-d88d-4deb-9ab3-f80631f9ff1d
:END:

[ This feature is subject to [[#h:91477890-49d5-48c3-9627-62295d2ab35d][The =init.el= user option to load extras for minibuffer completion]]. ]

I was not using ~consult~. Prot's description is comprehensive.
This looks like a steep learning curve for me but I'll use most
of his ~consult~ configuration.

~Consult~ "provides commands that turbocharge the minibuffer with
... filtering, asynchronous input, and contextual preview."

For asynchronous search, see also: [[#h:e0f9c30e-3a98-4479-b709-7008277749e4][The =bad-emacs-search.el=
module]].


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

  ;; Enhanced minibuffer commands (consult.el)
  (setq bad-emacs-completion-extras t)
  (when bad-emacs-completion-extras
    (use-package consult
      :ensure t
      :hook (completion-list-mode . consult-preview-at-point-mode)
      :bind
      ( :map global-map
        ("M-g M-g" . consult-goto-line)
        ("M-K" . consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
        ("M-F" . consult-focus-lines) ; same principle
        ("M-s M-b" . consult-buffer)
        ("M-s M-f" . consult-find)
        ("M-s M-g" . consult-grep)
        ("M-s M-h" . consult-history)
        ("M-s M-i" . consult-imenu)
        ("M-s M-l" . consult-line)
        ("M-s M-m" . consult-mark)
        ("M-s M-y" . consult-yank-pop)
        ("M-s M-s" . consult-outline)
        :map consult-narrow-map
        ("?" . consult-narrow-help))
      :config
      (setq consult-line-numbers-widen t)
      ;; (setq completion-in-region-function #'consult-completion-in-region)
      (setq consult-async-min-input 3)
      (setq consult-async-input-debounce 0.5)
      (setq consult-async-input-throttle 0.8)
      (setq consult-narrow-key nil)
      (setq consult-find-args
            (concat "find . -not ( "
                    "-path */.git* -prune "
                    "-or -path */.cache* -prune )"))
      (setq consult-preview-key 'any)
      (setq consult-project-function nil) ; always work from the current directory (use `cd' to switch directory)

      (add-to-list 'consult-mode-histories '(vc-git-log-edit-mode . log-edit-comment-ring))

      (require 'consult-imenu) ; the `imenu' extension is in its own file

      ))

#+end_src


*** The =bad-emacs-completion.el= section to configure completion annotations (~marginalia~)
:PROPERTIES:
:CUSTOM_ID: h:bd3f7a1d-a53d-4d3e-860e-25c5b35d8e7e
:END:

Prot's configuration here was minor and targeted to personal
preference, but he notes that the "out-of-the-box settings ...
are perfectly usable."

I'm going to use the defaults.

This is probably a good time to mention ~nerd-icons~. I use them
and there a add-on packages for things like ~marginalia~ and
~vertico~. I'll have to be sure to wire those back in.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

;; Detailed completion annotations (marginalia.el)
(use-package marginalia
  :ensure t
  :hook (after-init . marginalia-mode))
  ;; :config
  ;; 0 means never show, I was using the default.
  ;; (setq marginalia-max-relative-age 0)) ; absolute time

#+end_src


*** The =bad-emacs-completion.el= setting to load a minibuffer UI submodule
:PROPERTIES:
:CUSTOM_ID: h:db620e44-fc8f-45b8-a7fd-ae1d0b7ce86c
:END:

Prot's ~mct~ package is in maintenance mode and he expect it to
be superseded by base Emacs improvements over time.

I've been using ~vertico~ for a while so I'll force this
configuration to use it regardless of setting.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-completion.el"

  (setq bad-emacs-completion-ui 'vertico)
  (message "minibuffer completion hard coded for vertico")
;; VERTical Interactive COmpletion.
(use-package vertico
  :ensure t
  :hook (after-init . vertico-mode)
  :config
  (setq vertico-scroll-margin 0)
  (setq vertico-count 5)
  (setq vertico-resize t)
  (setq vertico-cycle t)

;;  (with-eval-after-load 'rfn-eshadow
    ;; This works with `file-name-shadow-mode' enabled.  When you are in
    ;; a sub-directory and use, say, `find-file' to go to your home '~/'
    ;; or root '/' directory, Vertico will clear the old path to keep
    ;; only your current input.
;;    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy))

  )

(use-package vertico-directory
  ;; comes along with vertico
  :after vertico
  :ensure nil
  :bind (:map vertico-map
              ("M-DEL" . vertico-directory-delete-word)))

  (provide 'bad-emacs-completion)
#+end_src


** The =bad-emacs-search.el= module
:PROPERTIES:
:CUSTOM_ID: h:e0f9c30e-3a98-4479-b709-7008277749e4
:END:

Prot has a comprehensive discussion of search and replace and
recommended extensions. They are worth a review but in the
interests of finishing this conversion I'm skipping over most of
his settings and using my current settings (just use the regexp
versions of isearch by default).

...For starters, just learn:

- =C-s=
- =C-r=
- =M-s o=
- =M-%=

Now on to the configurations.


*** The =bad-emacs-search.el= on isearch lax space
:PROPERTIES:
:CUSTOM_ID: h:95947b37-2071-4ee7-a201-8e19bf3322e9
:END:

This is something I was not aware of. Prot's changes remind me of
some of the things we would do at MDC in Lexis. "word /w5
otherword".

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el" :mkdirp yes

;;; Isearch, occur, grep, and extras (troi-search.el)
(use-package isearch
  :ensure nil
  :demand t
  :config
  ;; "find one two" would find "one two" "one hi there two" etc.
  (setq search-whitespace-regexp ".*?" ; one `setq' here to make it obvious they are a bundle
        isearch-lax-whitespace t
        isearch-regexp-lax-whitespace nil))

#+end_src


*** The =bad-emacs-search.el= settings for isearch highlighting
:PROPERTIES:
:CUSTOM_ID: h:ed1307e7-f8a0-4b0a-8d91-2de9c1e2479c
:END:

I need to experiment with these settings. One thing I've missed
from vim is persistent match highlighting. This just defers some
highlights, so it isn't what I want, but it's an area for
research.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package isearch
  :ensure nil
  :demand t
  :config
  (setq search-highlight t)
  (setq isearch-lazy-highlight t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 4))

#+end_src


*** The =bad-emacs-search.el= on isearch match counter
:PROPERTIES:
:CUSTOM_ID: h:acfdc17f-7ffb-48d3-90ff-49bd00463934
:END:

Oh wow. Display an occurrance/of counter? So obvious. Why isn't
it on by default? Old whiney users who resist change, like as
not.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package isearch
  :ensure nil
  :demand t
  :config
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format "(%s/%s) ")
  (setq lazy-count-suffix-format nil))

#+end_src


*** The =bad-emacs-search.el= tweaks to the isearch motion behaviour
:PROPERTIES:
:CUSTOM_ID: h:e6fd4ff0-86c7-423b-9cf3-0a9061505136
:END:

Change behavior on switching search directions from the current
"move to the other end of the current match" to just "move to the
next match in that direction."

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package isearch
  :ensure nil
  :demand t
  :config
  (setq isearch-wrap-pause t) ; `no-ding' makes keyboard macros never quit
  (setq isearch-repeat-on-direction-change t))

#+end_src


*** The =bad-emacs-search.el= tweaks for the occur buffer
:PROPERTIES:
:CUSTOM_ID: h:85aca4da-b89b-4fbe-89e9-3ec536ad7b0d
:END:

Quietly make the *occur* buffer more readable and position the
cursor in it.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package isearch
  :ensure nil
  :demand t
  :config
  (setq list-matching-lines-jump-to-current-line nil) ; do not jump to current line in `*occur*' buffers
  (add-hook 'occur-mode-hook #'troi-common-truncate-lines-silently) ; from `troi-common.el'
  (add-hook 'occur-mode-hook #'hl-line-mode))

#+end_src


*** The =bad-emacs-search.el= modified isearch and occur key bindings
:PROPERTIES:
:CUSTOM_ID: h:5ce6216d-f318-4191-9d4f-9681c92f7582
:END:

Some key rebinds. I did not know about ~isearch-abort~. Most
helpful! I'm not sure I'll use the completions, but I'll leave
them in.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package isearch
  :ensure nil
  :demand t
  :bind
  ( :map minibuffer-local-isearch-map
    ("M-/" . isearch-complete-edit)
    :map occur-mode-map
    ("t" . toggle-truncate-lines)
    :map isearch-mode-map
    ("C-g" . isearch-cancel) ; instead of `isearch-abort'
    ("M-/" . isearch-complete)))

#+end_src


*** The =bad-emacs-search.el= extras provided by the =troi-search.el= library
:PROPERTIES:
:CUSTOM_ID: h:b902e6a3-cdd2-420f-bc99-3d973c37cd20
:END:

Prot's search library provides a lot of extra functions. I'm not
sure I'll use them all but leaving the hook to it installed.

The changes are extensive, and extend to ~grep~, ~consult~, and
more. There are some hard coded regexps here, but it's hard to
complain about them as this is Prot's configuration and he's
sharing it.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(use-package troi-search
  :ensure nil
  :bind
  ( :map global-map
    ("M-s M-%" . troi-search-replace-markup) ; see `troi-search-markup-replacements'
    ("M-s M-<" . troi-search-isearch-beginning-of-buffer)
    ("M-s M->" . troi-search-isearch-end-of-buffer)
    ("M-s g" . troi-search-grep)
    ("M-s u" . troi-search-occur-urls)
    ("M-s t" . troi-search-occur-todo-keywords)
    ("M-s M-t" . troi-search-grep-todo-keywords) ; With C-u it runs `troi-search-git-grep-todo-keywords'
    ("M-s M-T" . troi-search-git-grep-todo-keywords)
    ("M-s s" . troi-search-outline)
    ("M-s M-o" . troi-search-occur-outline)
    ("M-s M-u" . troi-search-occur-browse-url)
    :map isearch-mode-map
    ("<up>" . troi-search-isearch-repeat-backward)
    ("<down>" . troi-search-isearch-repeat-forward)
    ("<backspace>" . troi-search-isearch-abort-dwim)
    ("<C-return>" . troi-search-isearch-other-end))
  :config
  (setq troi-search-outline-regexp-alist
        '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
          (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)")
          (outline-mode . "^\\*+ +")
          (emacs-news-view-mode . "^\\*+ +")
          (conf-toml-mode . "^\\[")
          (markdown-mode . "^#+ +")))
  (setq troi-search-todo-keywords
        (concat "TODO\\|FIXME\\|NOTE\\|REVIEW\\|XXX\\|KLUDGE"
                "\\|HACK\\|WARN\\|WARNING\\|DEPRECATED\\|BUG")))

#+end_src


*** The =bad-emacs-search.el= tweaks to ~xref~, ~re-builder~ and ~grep~
:PROPERTIES:
:CUSTOM_ID: h:ceb286c5-a5f7-4cc8-b883-89d20a75ea02
:END:

I've known about ~re-builder.el~ but haven't used it. I already
use ~ripgrep~ for xref and grep.

I'll want to change how the ~ripgrep~ executable to take into
account ~exec-path-from-shell~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

;;; grep and xref
(use-package re-builder
  :ensure nil
  :commands (re-builder regexp-builder)
  :config
  (setq reb-re-syntax 'read))

(use-package xref
  :ensure nil
  :commands (xref-find-definitions xref-go-back)
  :config
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative))

(use-package grep
  :ensure nil
  :commands (grep lgrep rgrep)
  :config
  (setq grep-save-buffers nil)
  (setq grep-use-headings t) ; Emacs 30

  (let ((executable (or (executable-find "rg") "grep"))
        (rgp (string-match-p "rg" grep-program)))
    (setq grep-program executable)
    (setq grep-template
          (if rgp
              "/usr/bin/rg -nH --null -e <R> <F>"
            "/usr/bin/grep <X> <C> -nH --null -e <R> <F>"))
    (setq xref-search-program (if rgp 'ripgrep 'grep))))

#+end_src


*** The =bad-emacs-search.el= setup for editable grep buffers (~grep-edit-mode~ or ~wgrep~)
:PROPERTIES:
:CUSTOM_ID: h:9a3581df-ab18-4266-815e-2edd7f7e4852
:END:

Starting with Emacs 31, buffers using ~grep-mode~ can now be
edited directly!

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

;; wgrep (writable grep)
;; See the `grep-edit-mode' for the new built-in feature.

(unless (>= emacs-major-version 31)
  (use-package wgrep
    :ensure t
    :after grep
    :bind
    ( :map grep-mode-map
      ("e" . wgrep-change-to-wgrep-mode)
      ("C-x C-q" . wgrep-change-to-wgrep-mode)
      ("C-c C-c" . wgrep-finish-edit))
    :config
    (setq wgrep-auto-save-buffer t)
    (setq wgrep-change-readonly-file t)))

#+end_src


*** The =bad-emacs-search.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:c8b2f021-fe5a-4f6b-944c-20340f764fb2
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-search.el"

(provide 'bad-emacs-search)

#+end_src


** The =bad-emacs-dired.el= module
:PROPERTIES:
:CUSTOM_ID: h:f8b08a77-f3a8-42fa-b1a9-f940348889c3
:END:

#+begin_quote
Dired lets us work with our files in a way that still feels close
to the command-line, yet has more powerful interactive features
than even fully fledged, graphical file managers.
#+end_quote


*** The =bad-emacs-dired.el= settings for common operations
:PROPERTIES:
:CUSTOM_ID: h:39fb0eab-54bb-4e5b-8e38-9443dbe5c5ee
:END:

Make operations on directories recursive and send deleted files
to the system trash.

NOTE: I added =:after exec-path-from-shell=, will it propogate to
others? I assume so.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el" :mkdirp yes

;;; Dired file manager and troi-dired.el extras
(use-package dired
  :after exec-path-from-shell
  :ensure nil
  :commands (dired)
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t))

#+end_src


*** The =bad-emacs-dired.el= switches for ~ls~ (how files are listed)
:PROPERTIES:
:CUSTOM_ID: h:679e4460-b306-450f-aa20-497243057e02
:END:

Use ~gls~ when it is available as the MacOs provided ~ls~ doesn't
work well with ~dired~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(use-package dired
  :ensure nil
  :commands (dired)
  :config

  (when (executable-find "gls")    ; use GNU ls
    (setopt dired-use-ls-dired nil)
    (setopt ls-lisp-use-insert-directory-program t)
    (setopt insert-directory-program "gls")
    ;; my old options (setopt dired-listing-switches "-alh --group-directories-first")
    )

  (setq dired-listing-switches
        "-aGFhlv --group-directories-first --time-style=long-iso"))

#+end_src


*** The =bad-emacs-dired.el= setting for dual-pane Dired
:PROPERTIES:
:CUSTOM_ID: h:8225364c-3856-48bc-bf64-60d40ddd3320
:END:

Helps to make dired operate a bit like Norton Commander did. By
setting ~dired-dwim-target~ to ~t~ the other buffer (pane) is the
default target of the current rename or copy.

If there are more than two windows showing Dired buffers, the
default target is the previously visited window.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(use-package dired
  :ensure nil
  :commands (dired)
  :config
  (setq dired-dwim-target t))

#+end_src


*** The =bad-emacs-dired.el= miscellaneous tweaks
:PROPERTIES:
:CUSTOM_ID: h:6327e6ba-a468-416f-ad26-b530c32fe235
:END:

Minor tweaks.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

  (use-package dired
    :ensure nil
    :commands (dired)
    :config
    (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'
    (setq dired-make-directory-clickable t) ; Emacs 29.1
    (setq dired-free-space nil) ; Emacs 29.1

  ;;  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
    (add-hook 'dired-mode-hook #'hl-line-mode)
  )

#+end_src


*** The =bad-emacs-dired.el= section about various conveniences
:PROPERTIES:
:CUSTOM_ID: h:6758bf16-e47e-452e-b39d-9d67c2b9aa4b
:END:

The =dired-aux.el= and =dired-x.el= are two built-in libraries
that provide useful extras for Dired.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(use-package dired-aux
  :ensure nil
  :after dired
  :bind
  ( :map dired-mode-map
    ("C-+" . dired-create-empty-file)
;;    ("M-s f" . nil)
;;    ("C-<return>" . dired-do-open) ; Emacs 30
;;    ("C-x v v" . dired-vc-next-action) ; Emacs 28
    )
  :config
  (setq dired-isearch-filenames 'dwim)
  (setq dired-create-destination-dirs 'ask) ; Emacs 27
  (setq dired-vc-rename-file t)             ; Emacs 27
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir)))) ; Emacs 28
)

(use-package dired-x
  :ensure nil
  :after dired
  :bind
  ( :map dired-mode-map
    ("I" . dired-info))
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  )

#+end_src


*** The =bad-emacs-dired.el= section about ~dired-subtree~
:PROPERTIES:
:CUSTOM_ID: h:3a4a29bc-3491-4d01-9d64-1cef63b3116a
:END:

The ~dired-subtree~ allows us to peek at the directory at point
more cleanly than dired does.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(use-package dired-subtree
  :ensure t
  :after dired
  :bind
  ( :map dired-mode-map
    ("<tab>" . dired-subtree-toggle)
    ("TAB" . dired-subtree-toggle)
    ("<backtab>" . dired-subtree-remove)
    ("S-TAB" . dired-subtree-remove))
  :config
  (setq dired-subtree-use-backgrounds nil))

#+end_src


*** The =bad-emacs-dired.el= section about ~wdired~ (writable Dired)
:PROPERTIES:
:CUSTOM_ID: h:1b53bc10-8b1b-4f68-bbec-165909761e43
:END:

Dired can be made writable. This way, we can quickly rename
multiple files using Emacs.

Note that we have a variant of ~wdired~ for ~grep~ buffers,
~wgrep~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(use-package wdired
  :ensure nil
  :commands (wdired-change-to-wdired-mode)
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

#+end_src


*** The =bad-emacs-dired.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:c8b2f021-fe5a-4f6b-944c-20340f764fb2
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-dired.el"

(provide 'bad-emacs-dired)

#+end_src


** The =bad-emacs-window.el= module
:PROPERTIES:
:CUSTOM_ID: h:b5fa481d-8549-4424-869e-91091cdf730b
:END:

Buffers and Windows and mismanagement of them.


*** The =bad-emacs-window.el= section about uniquifying buffer names
:PROPERTIES:
:CUSTOM_ID: h:cfbea29c-3290-4fd1-a02a-d7e887c15674
:END:

When a buffer name is reserved, Emacs tries to produce the new
buffer by finding a suitable variant of the original name. See
~uniquify-buffer-name-style~ for an explanation of the
possibilities.

Prot uses =forward= style while I've been running with the
default. We'll give his setup a try.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el" :mkdirp yes

;; General window and buffer configurations
(use-package uniquify
  :ensure nil
  :config
;; `uniquify' (unique names for buffers)
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))

#+end_src


*** The =bad-emacs-window.el= section about line highlighting (~hl-line-mode~)
:PROPERTIES:
:CUSTOM_ID: h:ec156866-3d25-42e7-8247-b190103b6f17
:END:

Prot isn't a fan of highlights, while I am.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

;; Line highlight
(use-package hl-line
  :ensure nil
  :commands (global-hl-line-mode hl-line-mode)
  :config
  (global-hl-line-mode)
)

#+end_src


*** The =bad-emacs-window.el= section about line numbers (~display-line-numbers-mode~)
:PROPERTIES:
:CUSTOM_ID: h:f45ea51c-8129-41bd-8d6e-4b66e7f35a49
:END:

Again, Prot isn't a fan, but I am.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

;; Line numbers on the side of the window
(use-package display-line-numbers
  :ensure nil
  :hook (prog-mode . display-line-numbers-mode)
  :config
  (setq-default display-line-numbers-width 4)
  ;;(setopt display-line-numbers-width 4)
  ;; Use absolute numbers in narrowed buffers
  (setq-default display-line-numbers-widen t))

#+end_src


*** The =bad-emacs-window.el= rules for displaying buffers (~display-buffer-alist~)
:PROPERTIES:
:CUSTOM_ID: h:50f8b1e4-b14e-453f-a37e-1c0e495ab80f
:END:

[ Watch: [[https://protesilaos.com/codelog/2024-02-08-emacs-window-rules-display-buffer-alist/][control where buffers are displayed (the ~display-buffer-alist~)]] (2024-02-08). ]

#+begin_quote
The ~display-buffer-alist~ is a powerful user option and somewhat
hard to get started with. The reason for its difficulty comes
from the knowledge required to understand the underlying
~display-buffer~ mechanism.

Here is the gist of what we do with it ...
#+end_quote

Prot offers a detailed explanation that I won't repeat here. It's
available online and I need to watch the video he refrences.

I'm leaving this in as he wrote it to see what happens, but I
don't use a huge display and usually have no more than two
buffers visible at a time (not counting transient buffers).

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

;; `window', `display-buffer-alist', and related

(use-package troi-window
    :ensure nil
    :demand t
    :config
    ;; NOTE 2023-03-17: Remember that I am using development versions of
    ;; Emacs.  Some of my `display-buffer-alist' contents are for Emacs
    ;; 29+.
    (setq display-buffer-alist
          `(;; no window
            ("\\`\\*Async Shell Command\\*\\'"
             (display-buffer-no-window))
            ("\\`\\*\\(Warnings\\|Compile-Log\\|Org Links\\)\\*\\'"
             (display-buffer-no-window)
             (allow-no-window . t))
            ;; bottom side window
            ("\\*Org \\(Select\\|Note\\)\\*" ; the `org-capture' key selection and `org-add-log-note'
             (display-buffer-in-side-window)
             (dedicated . t)
             (side . bottom)
             (slot . 0)
             (window-parameters . ((mode-line-format . none))))
            ;; bottom buffer (NOT side window)
            ((or . ((derived-mode . flymake-diagnostics-buffer-mode)
                    (derived-mode . flymake-project-diagnostics-mode)
                    (derived-mode . messages-buffer-mode)
                    (derived-mode . backtrace-mode)))
             (display-buffer-reuse-mode-window display-buffer-at-bottom)
             (window-height . 0.3)
             (dedicated . t)
             (preserve-size . (t . t)))
            ("\\*Embark Actions\\*"
             (display-buffer-reuse-mode-window display-buffer-below-selected)
             (window-height . fit-window-to-buffer)
             (window-parameters . ((no-other-window . t)
                                   (mode-line-format . none))))
            ("\\*\\(Output\\|Register Preview\\).*"
             (display-buffer-reuse-mode-window display-buffer-at-bottom))
            ;; below current window
            ("\\(\\*Capture\\*\\|CAPTURE-.*\\)"
             (display-buffer-reuse-mode-window display-buffer-below-selected))
            ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
             (display-buffer-reuse-mode-window display-buffer-below-selected)
             (window-height . 0.1)
             (dedicated . t)
             (preserve-size . (t . t)))
            ((derived-mode . reb-mode) ; M-x re-builder
             (display-buffer-reuse-mode-window display-buffer-below-selected)
             (window-height . 4) ; note this is literal lines, not relative
             (dedicated . t)
             (preserve-size . (t . t)))
            ((or . ((derived-mode . occur-mode)
                    (derived-mode . grep-mode)
                    (derived-mode . Buffer-menu-mode)
                    (derived-mode . log-view-mode)
                    (derived-mode . help-mode) ; See the hooks for `visual-line-mode'
                    "\\*\\(|Buffer List\\|Occur\\|vc-change-log\\|eldoc.*\\).*"
                    troi-window-shell-or-term-p
                    ;; ,world-clock-buffer-name
                    ))
             (troi-window-display-buffer-below-or-pop)
             (body-function . troi-window-select-fit-size))
            ("\\*\\(Calendar\\|Bookmark Annotation\\|ert\\).*"
             (display-buffer-reuse-mode-window display-buffer-below-selected)
             (dedicated . t)
             (window-height . fit-window-to-buffer))
            ;; NOTE 2022-09-10: The following is for `ispell-word', though
            ;; it only works because I override `ispell-display-buffer'
            ;; with `troi-spell-ispell-display-buffer' and change the
            ;; value of `ispell-choices-buffer'.
            ("\\*ispell-top-choices\\*.*"
             (display-buffer-reuse-mode-window display-buffer-below-selected)
             (window-height . fit-window-to-buffer))
            ;; same window

            ;; NOTE 2023-02-17: `man' does not fully obey the
            ;; `display-buffer-alist'.  It works for new frames and for
            ;; `display-buffer-below-selected', but otherwise is
            ;; unpredictable.  See `Man-notify-method'.
            ((or . ((derived-mode . Man-mode)
                    (derived-mode . woman-mode)
                    "\\*\\(Man\\|woman\\).*"))
             (display-buffer-same-window)))))

#+end_src

The following settings are relevant for the
~display-buffer-alist~ we saw right above....

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

(use-package troi-window
  :ensure nil
  :demand t
  :config
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq split-height-threshold 80)
  (setq split-width-threshold 125)
  (setq window-min-height 3)
  (setq window-min-width 30))

#+end_src


*** The =bad-emacs-window.el= setting to enable ~visual-line-mode~ in some contexts
:PROPERTIES:
:CUSTOM_ID: h:bf3f50d5-c5db-4704-9498-9e8bfe1b45a8
:END:

Yet another case of something I like that Prot doesn't use often.

This is probably a good place to add visual-fill-column-mode
since it is related.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

(use-package troi-window
  :ensure nil
  :demand t
  :hook
  ((epa-info-mode help-mode Custom-mode) . visual-line-mode))

(use-package visual-fill-column
  :ensure t
  :after org
  :init
  ;; this has to be done before visual-fill-column loads.
  (mouse-wheel-mode -1)
  :hook
  (text-mode . visual-line-mode) ;; will this work here? it should
  (org-mode . visual-line-mode)
  ;; (org-mode . visual-fill-column-mode)
  )

#+end_src


*** The =bad-emacs-window.el= section key bindings
:PROPERTIES:
:CUSTOM_ID: h:49ad5448-2ccd-4f47-82fd-17819ffdbdf3
:END:

I need to make better use of buffer switching.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"
(use-package troi-window
  :ensure nil
  :demand t
  :bind
  ( :map global-map
    ;; NOTE 2022-09-17: Also see `troi-simple-swap-window-buffers'.
    ("C-x <down>" . next-buffer)
    ("C-x <up>" . previous-buffer)
    ("C-x C-n" . next-buffer)     ; override `set-goal-column'
    ("C-x C-p" . previous-buffer) ; override `mark-page'
    ("C-x !" . delete-other-windows-vertically)
    ("C-x _" . balance-windows)      ; underscore
    ("C-x -" . fit-window-to-buffer) ; hyphen
    ("C-x +" . balance-windows-area)
    ("C-x }" . enlarge-window)
    ("C-x {" . shrink-window)
    ("C-x >" . enlarge-window-horizontally) ; override `scroll-right'
    ("C-x <" . shrink-window-horizontally) ; override `scroll-left'
    :map resize-window-repeat-map
    (">" . enlarge-window-horizontally)
    ("<" . shrink-window-horizontally)))
#+end_src


*** The =bad-emacs-window.el= ~provide~ form
:PROPERTIES:
:CUSTOM_ID: h:2124c200-734d-49c4-aeb1-513caaf957ae
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-window.el"

(provide 'bad-emacs-window)

#+end_src


** The =bad-emacs-git.el= module
:PROPERTIES:
:CUSTOM_ID: h:65e3eff5-0bff-4e1f-b6c5-0d3aa1a0d232
:END:

[ Watch: [[https://protesilaos.com/codelog/2023-08-03-contribute-core-emacs/][Contribute to GNU Emacs core]] (2023-08-03). ]

Git and projects. I barely use Git but Prot contributes to many
projects so his configuration should be instructive.


*** The =bad-emacs-git.el= section about ediff
:PROPERTIES:
:CUSTOM_ID: h:89edea05-4d94-4ea1-b2a8-5ad01422618c
:END:

[ Watch: [[https://protesilaos.com/codelog/2023-11-17-emacs-ediff-basics/][Emacs: ediff basics]] (2023-12-30) ]

~ediff~ provides side by side comparison. I've tried it and have
not enjoyed it, but I finally learned the incantation to get it
to not open a second frame.

Prot doesn't like its defaults either:

#+begin_quote
it puts buffers one on top of the other and places the "control
panel" in a separate Emacs frame. The first time I tried to use
it, I thought I broke my setup because it is unlike anything we
normally interact with.
#+end_quote


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el" :mkdirp yes

;; `ediff'
(use-package ediff
  :ensure nil
  :commands (ediff-buffers ediff-files ediff-buffers3 ediff-files3)

  :init
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t))

#+end_src


*** The =bad-emacs-git.el= section about =project.el=
:PROPERTIES:
:CUSTOM_ID: h:7dcbcadf-8af6-487d-b864-e4ce56d69530
:END:

In Emacs a "project" is a collection of files and directories
that share the same root. The root of a project is usually a
special file or directory. In my case that will be ~.git/~.

Prot has a library (in [[#h:654cfe49-f59d-4a0d-84ee-094ddce06848][the =troi-project.el= library]] package)
that may have useful functions but it isn't part of this
configuration.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el"

;; `project'
(use-package project
  :ensure nil
  :bind
  (("C-x p ." . project-dired)
   ("C-x p C-g" . keyboard-quit)
   ("C-x p <return>" . project-dired)
   ("C-x p <delete>" . project-forget-project))
  :config
  (setopt project-switch-commands
          '((project-find-file "Find file")
            (project-find-regexp "Find regexp")
            (project-find-dir "Find directory")
            (project-dired "Root dired")
            (project-vc-dir "VC-Dir")
            (project-shell "Shell")
            (keyboard-quit "Quit")))
  (setq project-vc-extra-root-markers '(".project")) ; Emacs 29
  (setq project-key-prompt-style t) ; Emacs 30

  (advice-add #'project-switch-project :after #'troi-common-clear-minibuffer-message))

#+end_src


*** The =bad-emacs-git.el= section about ~diff-mode~
:PROPERTIES:
:CUSTOM_ID: h:8b426a69-e3cd-42ac-8788-f41f6629f879
:END:

This built-in mode for working with standard Unix diffs.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el"

;; `diff-mode'
(use-package diff-mode
  :ensure nil
  :defer t
  :config
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil) ; I do it on demand, with my `agitate' package (more below)
  (setq diff-font-lock-prettify nil)
  (setq diff-font-lock-syntax 'hunk-also))

#+end_src


*** The =bad-emacs-git.el= section about =vc.el= and related
:PROPERTIES:
:CUSTOM_ID: h:50add1d8-f0f4-49be-9e57-ab280a4aa300
:END:

Emacs' ~vc~ is a good abstraction that works with most version
control software (svn, git, etc).


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el"

;; Version control framework (vc.el, vc-git.el, and more)
(use-package vc
  :ensure nil
  :init
  (setq vc-follow-symlinks t)
  :config
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  (setq vc-handled-backends '(Git))

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; I can see the files from the Diff with C-c C-d
  (remove-hook 'log-edit-hook #'log-edit-show-files)

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-log-switches '("--stat"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        `("%d %h %ai %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          ,(concat "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?"
                   "\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) "
                   "\\(?4:[0-9]\\{4\\}-[0-9-]\\{4\\}[0-9\s+:-]\\{16\\}\\) "
                   "\\(?3:.*?\\):")
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  ;; These two are from Emacs 29
  (setq vc-git-log-edit-summary-target-len 50)
  (setq vc-git-log-edit-summary-max-len 70))

#+end_src


*** The =bad-emacs-git.el= section about ~magit~ (great Git client)
:PROPERTIES:
:CUSTOM_ID: h:b08af527-9ebf-4425-ac3a-24b4f371a4fd
:END:

The ~magit~ package is considered the best way to work with and
learn ~git~. I am barely a cargo cult user of Git, so hopefully
examining this configuration will help me learn more about it.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el"

;; Interactive and powerful git front-end (Magit)
(use-package transient
  :defer t
  :config
  (setq transient-show-popup 0.5))

(use-package magit
  :ensure t
  :bind ("C-c g" . magit-status)
  :init
  (setq magit-define-global-key-bindings nil)
  (setq magit-section-visibility-indicator '(""))
  :config
  (setq git-commit-summary-max-length 50)
  ;; NOTE 2023-01-24: I used to also include `overlong-summary-line'
  ;; in this list, but I realised I do not need it.  My summaries are
  ;; always in check.  When I exceed the limit, it is for a good
  ;; reason.
  (setq git-commit-style-convention-checks '(non-empty-second-line))

  (setq magit-diff-refine-hunk t))

(use-package magit-repos
  :ensure nil ; part of `magit'
  :commands (magit-list-repositories)
  :init
  (setq magit-repository-directories
        '(("~/projects" . 1))))

#+end_src


*** The =bad-emacs-git.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:4e7035c5-9350-4c51-be85-85f2539ed295
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-git.el"

(provide 'bad-emacs-git)

#+end_src


** The =bad-emacs-org.el= module
:PROPERTIES:
:CUSTOM_ID: h:d799c3c0-bd6a-40bb-bd1a-ba4ea5367840
:END:

Videos:

- [[https://protesilaos.com/codelog/2023-12-18-emacs-org-advanced-literate-conf/][Advanced literate configuration with Org]] (2023-12-18)
- [[https://protesilaos.com/codelog/2023-05-23-emacs-org-basics/][Basics of Org mode]] (2023-05-23)
- [[https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/][Demo of my custom Org block agenda]] (2021-12-09)
- [[https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/][Primer on "org-capture"]] (2020-02-04)

Org is a markup language over plain text files that has an
extensive library of code in Emacs. The markup reminds me a bit
of old school wiki-wiki and the indexing and capture and
presentation in Emacs reminds me of Ecco.

This section has Org configurations broken out by functionality
along with configurations for related built-in applications.


*** The =bad-emacs-org.el= section on the ~calendar~
:PROPERTIES:
:CUSTOM_ID: h:94d48381-1711-4d6b-8449-918bc1e3836c
:END:

I use my Apple apps for scheduling, but Org and calendar do
interact so I'm leaving this configuration here for now.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el" :mkdirp yes

;; Calendar
(use-package calendar
  :ensure nil
  :commands (calendar)
  :config
  (setq calendar-mark-diary-entries-flag nil)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '( 24-hours ":" minutes
           (when time-zone (format "(%s)" time-zone))))
  (setq calendar-week-start-day 0)      ; Sunday
  (setq calendar-date-style 'iso)
)

#+end_src


*** The =bad-emacs-org.el= section with basic Org settings
:PROPERTIES:
:CUSTOM_ID: h:e03df1e0-b43e-49b5-978e-6a511165617c
:END:

Org-mode. One ring to rule them all. Text editing, formatting,
literate programming, indexing, time tracking, charts, ...

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"
  ;;; Org-mode (personal information manager)
(use-package org
  :ensure nil
  :init
  (setq org-directory (expand-file-name "~/org/"))
  (setq org-imenu-depth 7)

  (add-to-list 'safe-local-variable-values '(org-hide-leading-stars . t))
  (add-to-list 'safe-local-variable-values '(org-hide-macro-markers . t))
  :bind
  ( :map global-map
    ("C-c l" . org-store-link)
    ("C-c o" . org-open-at-point-global)
    :map org-mode-map
    )
  :config
  ;; My custom extras, which I use for the agenda and a few other Org features.

  (require 'troi-org)

  ;; leaving a few of these
  ;;;; general settings
  ;;  (setq org-ellipsis "")
  (setq org-adapt-indentation nil)      ; No, non, nein, !
  ;;    (setq org-special-ctrl-a/e nil)
  ;;    (setq org-special-ctrl-k nil)
  ;;    (setq org-M-RET-may-split-line '((default . nil)))
  ;;    (setq org-hide-emphasis-markers nil)
  ;;    (setq org-hide-macro-markers nil)
  ;;    (setq org-hide-leading-stars nil)
  ;;    (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist
	        '(
	  ("C" . "comment")
	  ("q" . "quote")
	  ("c" . "center")
	  ("v" . "verse")
          ("x" . "example")

	  ("a" . "export ascii")
          ("X" . "export")

	  ("s" . "src")
          ("e" . "src emacs-lisp")

          ("t" . "src emacs-lisp :tangle FILENAME")
          ("E" . "src emacs-lisp :results value code :lexical t")
          ("T" . "src emacs-lisp :tangle FILENAME :mkdirp yes")
	  ))
;;  (setq org-fold-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info))
  (setq org-use-sub-superscripts '{})
;;  (setq org-insert-heading-respect-content t)
;;  (setq org-read-date-prefer-future 'time)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-block-delimiter-line t)
;;  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?B)
  (setq org-priority-faces nil)
  )
#+end_src


*** The =bad-emacs-org.el= Org to-do and refile settings
:PROPERTIES:
:CUSTOM_ID: h:024dd541-0061-4a10-b10b-b17dcd4794b9
:END:

I don't find any of the apps in the Apple ecosystem to my liking
for to-do and the like. Prot's customizations were extensive and
geared to his workflow, I'm taking it to almost stock. When I do
this I'm making sure to check each variable's default value.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; refile, todo
(use-package org
  :ensure nil
  :config
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "CANCEL(c@)" "DONE(d!)"))))

#+end_src


*** The =bad-emacs-org.el= Org heading tags
:PROPERTIES:
:CUSTOM_ID: h:81de4e32-a1af-4e1f-9e10-90eb0c90afa2
:END:

Each Org heading can have one or more tags associated with it,
while all headings inherit any potential =#+FILETAGS=. We can add
tags to a heading when the cursor is over it by typing the ever
flexible =C-c C-c=. Though the more specific
~org-set-tags-command~ also gets the job done, plus it does not
require that the cursor is positioned on the heading text.

Tagging is useful for search and retrieval.

~org-tag-alist~ holds our standard tags. File level tags are
available via ~#+TAGS~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; tags
(use-package org
  :ensure nil
  :config
  (setq org-tag-alist nil)
;;  (setq org-auto-align-tags nil)
;;  (setq org-tags-column 0))
)

#+end_src


*** The =bad-emacs-org.el= Org time/state logging
:PROPERTIES:
:CUSTOM_ID: h:0884658e-9eb5-47e3-9338-66e09004a1a0
:END:

Org can keep a record of state changes. I'm not sure I'll use
this, we'll see.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; log
(use-package org
  :ensure nil
  :config
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  )

#+end_src


*** The =bad-emacs-org.el= Org link settings
:PROPERTIES:
:CUSTOM_ID: h:da8ce883-7f21-4a6e-a41f-d668ad762b41
:END:

(Oprah voice): You get a link, and you get a link and you get a
link!

- [[#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d][The =bad-emacs-org.el= Org capture templates (~org-capture~)]]
- [[#h:49890997-448e-408d-bebe-2003259bb125][The =bad-emacs-notmuch.el= glue code for ~org-capture~ (=ol-notmuch.el=)]]

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; links
(use-package org
  :ensure nil
  :config
  (require 'troi-org) ; for the above commands

  (setq org-link-context-for-files t)
  (setq org-link-keep-stored-after-insertion nil)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))

#+end_src


*** The =bad-emacs-org.el= Org code block settings
:PROPERTIES:
:CUSTOM_ID: h:1f5a0d46-5202-48dd-8048-b48ce17f3df8
:END:

This document benefits from Org's ability to combine prose with
code by wrapping the code in blocks delimited by =#+BEGIN_SRC=
and =#+END_SRC= lines.

Org can evaluate code blocks and pass the result to other code
blocks. The code can be in almost any language thanks to "Org
Babel".

To evaluate a code block with =C-c C-c=. The results will be
produced below the code block.

There are many types of blocks:

- =#+BEGIN_QUOTE= :: Treat the contents as a block quote.

- =#+BEGIN_VERSE= :: Honor line breaks, as in verse.

- =#+BEGIN_EXPORT= :: Evaluate the code for a target (like =html=
  or =latex=).

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; code blocks
(use-package org
  :ensure nil
  :config
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0))

#+end_src


*** The =bad-emacs-org.el= Org export settings
:PROPERTIES:
:CUSTOM_ID: h:bd11d4d8-6e9f-4536-87a4-4018783bf8f5
:END:

Org can export a document to other file formats (text to PDF,
HTML, texinfo, etc.).

The default export targets are specified in
~org-export-backends~, which must be set before the org package
is loaded -or- by loading the proper ox-<format>.el package.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; export
(use-package org
  :ensure nil
  :init
  ;; NOTE 2023-05-20: Must be evaluated before Org is loaded,
  ;; otherwise we have to use the Custom UI.
  (setq org-export-backends '(ascii icalendar odt html))
  :config
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 5)
  )

#+end_src


*** The =bad-emacs-org.el= Org capture templates (~org-capture~)
:PROPERTIES:
:CUSTOM_ID: h:f8f06938-0dfe-45c3-b4cf-996d36cba82d
:END:

The ~org-capture~ command allows us to quickly store data in some
structured way using templates. I'm starting with Prot's
templates until I figure out what makes sense for me.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; capture
(use-package org-capture
  :ensure nil
  :bind ("C-c c" . org-capture)
  :config
  (require 'troi-org)

  (setq org-capture-templates
        `(("u" "Unprocessed" entry
           (file+headline "tasks.org" "Unprocessed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)
          ("w" "Wishlist" entry
           (file+olp "tasks.org" "All tasks" "Wishlist")
           ,(concat "* %^{Title} %^g\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%?")
           :empty-lines-after 1)
          ("t" "Task to do" entry
           (file+headline "tasks.org" "All tasks")
           ,(concat "* TODO %^{Title} %^g\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%?")
           :empty-lines-after 1)
          ("s" "Select file and heading to add to" entry
           (function troi-org-select-heading-in-file)
           ,(concat "* TODO %^{Title}%?\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n")
           :empty-lines-after 1)
	  )))

#+end_src


*** The =bad-emacs-org.el= Org agenda settings
:PROPERTIES:
:CUSTOM_ID: h:7fe87b83-2815-4617-a5f9-d3417dd9d248
:END:

With the Org agenda, we can visualise the tasks we have collected
in the files listed in ~org-agenda-files~.

Org provides many different views of the agenda (daily agenda by
time, todo lists, etc). Views may be customized and filtered.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

;; agenda
(use-package org-agenda
  :ensure nil
  :bind
  ;; I bind `org-agenda' to C-c A, so this one puts me straight into my
  ;; custom block agenda.
  ( :map global-map
    ("C-c A" . org-agenda)
    ("C-c a" . (lambda ()
                 "Call Org agenda with `troi-org-custom-daily-agenda' configuration."
                 (interactive)
                 (org-agenda nil "A"))))
  :config

;; Custom agenda blocks

  (setq org-agenda-format-date #'troi-org-agenda-format-date-aligned)

;; Basic agenda setup
  (setq org-default-notes-file (concat org-directory "org-notes-"))
  (setq org-agenda-files `(,org-directory))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 0)  ; Sunday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-sticky nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil))

#+end_src


*** The =bad-emacs-org.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:62eb7ca3-2f79-45a6-a018-38238b486e98
:END:

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-org.el"

(provide 'bad-emacs-org)

#+end_src


** The =bad-emacs-langs.el= module
:PROPERTIES:
:CUSTOM_ID: h:f44afb76-a1d7-4591-934d-b698cc79a792
:END:

This module encompasses a wide range of packages and built-in
configurations that relate to "language" in the wider sense.
Settings here include basic patterns of interaction, such as what
the =TAB= key does, to spell checking, code linting, and writing.


*** The =bad-emacs-langs.el= settings for TAB
:PROPERTIES:
:CUSTOM_ID: h:559713c8-0e1e-44aa-bca8-0caae01cc8bb
:END:

Tabs are very personal preferences. Tab has multiple purposes in
Emacs. I'm apparently a minority in preferring that tabs actually
tab and not space.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el" :mkdirp yes

;;;; Tabs, indentation, and the TAB key
(use-package emacs
  :ensure nil
  :demand t
  :config
  (setq tab-always-indent 'complete)
  (setq tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
  ;; these become buffer local when set, so ...
  (setq-default tab-width 8
                indent-tabs-mode t))

#+end_src


*** The =bad-emacs-langs.el= settings ~show-paren-mode~
:PROPERTIES:
:CUSTOM_ID: h:7cd21ea6-c5d8-4258-999d-ad94cac2d8bf
:END:

~Show-paren-mode~ highlights the matching character or word of bracketing constructs: close paren for an open, end for a begin, etc.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Parentheses (show-paren-mode)
(use-package paren
  :ensure nil
  :hook (prog-mode . show-paren-local-mode)
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (setq show-paren-context-when-offscreen 'overlay)) ; Emacs 29

#+end_src


*** The =bad-emacs-langs.el= settings for plain text (no double spaces, ~auto-fill-mode~)
:PROPERTIES:
:CUSTOM_ID: h:c5fbd6dd-2982-4fca-aeed-d0e750d399bd
:END:

I prefer two spaces for sentence ends, but I also like the Oxford
comma. I've relented on sentence ends, but apparently in Emacs
Lisp a period mut be followed by two spaces.

~auto-fill-mode~ will break long lines at the ~fill-column~
length automatically as you type. In this mode paragraphs are not
a single long line, but multiple small lines.

For pure prose, I prefer ~visual-line-mode~ which visually wraps
long lines. There are good reasons not, but I use it anyway. On
wide screens this can lead to painfully long lines, but there is
a package for ~visual-fill-column-mode~.

There are commands to fill text bound to =M-q= and =M-q=. Prot
has an a command to to unfile a region or paragraph. If I find it
natural enough, I may switch away from ~visual-line-mode~.

The regular expresion in the :mode parameter puts files with
those names will be in ~text-mode~ instead of ~fundamental-mode~.
Mode recognition is not limited to file extensions.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Plain text (text-mode)
(use-package text-mode
  :ensure nil
  :mode "\\`\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)\\'"
  :hook
  ((text-mode . turn-on-auto-fill)
   (prog-mode . (lambda () (setq-local sentence-end-double-space t))))
  :config
  (setq sentence-end-double-space nil)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t))

#+end_src


*** The =bad-emacs-langs.el= settings for common file types
:PROPERTIES:
:CUSTOM_ID: h:1a132701-9487-4af0-8759-a8d64d02bf1f
:END:

Here are some odd file types for OS artifacts and configuration
files.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Arch Linux and AUR package scripts (sh-mode)
(use-package sh-script
  :ensure nil
  :mode ("PKGBUILD" . sh-mode))

;; SystemD and other configuration files (conf-mode)
(use-package conf-mode
  :ensure nil
  :mode ("\\`dircolors\\'" "\\.\\(service\\|timer\\)\\'"))

#+end_src


*** The =bad-emacs-langs.el= settings for ~eldoc~
:PROPERTIES:
:CUSTOM_ID: h:a5773a39-a78f-43fa-8feb-669492c1d5a9
:END:

Before there were tooltips in IDEs, there was Eldoc. It works for
Emacs Lisp automatically, and can be configured for other
programming languages.


#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Eldoc (Emacs live documentation feedback)
(use-package eldoc
  :ensure nil
  :hook (prog-mode . eldoc-mode)
  :config
  (setq eldoc-message-function #'message)) ; don't use mode line for M-x eval-expression, etc.

#+end_src


*** The =bad-emacs-langs.el= settings for ~eglot~ (LSP client)
:PROPERTIES:
:CUSTOM_ID: h:92258aa8-0d8c-4c12-91b4-5f44420435ce
:END:

I've seen the light and now use ~eglot~. It is much better than
tagging/regexp based language modes with the caveat that an lsp
for your target language must exist.

So far the only servers I need are ~clangd~ for C and ~ols~ for
Odin.

Eglot requires minimal configuration and uses Emacs' Flymake for
error reporting. You can turn it on automatically in a mode hook
or manually with =M-x eglot=.

Prot's configuration is lighter than mine so I'm pulling in some
of my configuration that I know will work on my system.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Eglot (built-in client for the language server protocol)
;; as Eglot is still in development, updates are pushed
;; to the gnu package server.

(use-package eglot
  :ensure t
  :pin gnu
  :after exec-path-from-shell
  :functions (eglot-ensure)
  :commands (eglot)
  :hook
  (c-ts-mode . eglot-ensure)
  (c++-ts-mode . eglot-ensure)
  (odin-mode . eglot-ensure)
  :bind (:map eglot-mode-map
              ("C-c c a" . eglot-code-actions)
              ("C-c c r" . eglot-rename))
  :config
  ;; When debugging `eglot' issues, comment out the `fset' and
  ;; `events-buffer-config' lines below.
  (fset #'jsonrpc--log-event #'ignore)  ; massive perf boost---don't log every event
  (setopt jsonrpc-event-hook nil)
  :custom
  (eglot-events-buffer-config '(:size 0 :format short))
  (eglot-autoshutdown t)
  (eglot-send-changes-idle-time 0.1)
  (eglot-extend-to-xref t)
  (eglot-report-progress nil)  ; Prevent minibuffer spam
  (eglot-ignored-server-capabilities '(:documentFormattingProvider           :documentRangeFormattingProvider                 :documentOnTypeFormattingProvider))
)

#+end_src


*** The =bad-emacs-langs.el= settings for very long lines
:PROPERTIES:
:CUSTOM_ID: h:20948a81-858d-4b21-b221-3b24833f5ad8
:END:

Emacs can bog down on files with very long lines (minified JS,
etc). The ~global-so-long-mode~ disables some features. I also
remove the scan for right-to-left languages, which Prot doesn't
do but he is more likely to deal with those than I am.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Handle performance for very long lines (so-long.el)
(use-package so-long
  :ensure nil
  :hook (after-init . global-so-long-mode)
  :custom
  (bidi-paragraph-direction 'left-to-right))

#+end_src


*** The =bad-emacs-langs.el= settings for ~markdown-mode~
:PROPERTIES:
:CUSTOM_ID: h:c9063898-07ae-4635-8853-bb5f4bbab421
:END:

I try to avoid Markdown, but sometimes I have to work with it.
Enter ~markdown-mode.~

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Markdown (markdown-mode)
(use-package markdown-mode
  :ensure t
  :defer t
  :config
  (setq markdown-fontify-code-blocks-natively t))

#+end_src


*** The =bad-emacs-langs.el= settings for spell checking
:PROPERTIES:
:CUSTOM_ID: h:115806c4-88b0-43c1-8db2-d9d8d20a5c17
:END:

Prot uses ~flyspell~ with some additional code in his spell
support library. He prefers on-demand instead of constant spell
checking.

I have not really needed spell checking, but I'll take his
configuration as a starting point.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Flyspell and troi-spell.el (spell check)
(use-package flyspell
  :ensure nil
  :bind
  ( :map flyspell-mode-map
    ("C-;" . nil)
    :map flyspell-mouse-map
    ("<mouse-3>" . flyspell-correct-word)
    :map ctl-x-x-map
    ("s" . flyspell-mode)) ; C-x x s
  :config
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_US"))

(use-package troi-spell
  :ensure nil
  :bind
  (("M-$" . troi-spell-spell-dwim)
   ("C-M-$" . troi-spell-change-dictionary)
   ("M-i" . troi-spell-spell-dwim) ; override `tab-to-tab-stop'
   ("C-M-i" . troi-spell-change-dictionary)) ; override `complete-symbol'
  :config
  (setq troi-spell-dictionaries
        '(("EN English" . "en")))

  ;; Also check troi-spell.el for what I am doing with
  ;; `troi-spell-ispell-display-buffer'.  Then refer to the
  ;; `display-buffer-alist' for the relevant entry.
  (setq ispell-choices-buffer "*ispell-top-choices*"))

#+end_src


*** The =bad-emacs-langs.el= settings for code linting (~flymake~)
:PROPERTIES:
:CUSTOM_ID: h:df6d1b52-0306-4ace-9099-17dded11fbed
:END:

~flymake~ is a built-in that presents output from linter
programs, LSP servers, and even compiler error messages.

With ~flymake~ we get these diagnostics in the form of a
standalone buffer as well as inline highlights (typically
underlines combined with fringe indicators).

The ~package-lint-flymake~ is helpful for anyone working with
Emacs Lisp packages.

TODO: Prot integrates with his custom modeline, which I don't
expect to use, so there will be some settling in problems to work
through

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; Flymake
(use-package flymake
  :ensure nil
  :preface
  (defvar troi/flymake-mode-projects-path
    (file-name-as-directory (expand-file-name "Projects" "~/projects/"))
    "Path to my Git projects.")

  (defun troi/flymake-mode-lexical-binding ()
    (when lexical-binding
      (flymake-mode 1)))

  (defun troi/flymake-mode-in-my-projects ()
    (when-let* ((file (buffer-file-name))
                ((string-prefix-p troi/flymake-mode-projects-path (expand-file-name file)))
                ((not (file-directory-p file)))
                ((file-regular-p file)))
      (add-hook 'find-file-hook #'troi/flymake-mode-lexical-binding nil t)))

  (add-hook 'emacs-lisp-mode-hook #'troi/flymake-mode-in-my-projects)
  :bind
  ( :map ctl-x-x-map
    ("m" . flymake-mode) ; C-x x m
    :map flymake-mode-map
    ("C-c ! s" . flymake-start)
    ("C-c ! d" . flymake-show-buffer-diagnostics) ; Emacs28
    ("C-c ! D" . flymake-show-project-diagnostics) ; Emacs28
    ("C-c ! n" . flymake-goto-next-error)
    ("C-c ! p" . flymake-goto-prev-error))
  :config
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  (setq flymake-mode-line-format
        '("" flymake-mode-line-exception flymake-mode-line-counters))
  ;; NOTE 2023-07-03: `troi-modeline.el' actually defines the counters
  ;; itself and ignores this.
  (setq flymake-mode-line-counter-format
        '("" flymake-mode-line-error-counter
          flymake-mode-line-warning-counter
          flymake-mode-line-note-counter ""))
  (setq flymake-show-diagnostics-at-end-of-line nil)) ; Emacs 30

;;; Elisp packaging requirements
(use-package package-lint-flymake
  :ensure t
  :after flymake
  :config
  (add-hook 'flymake-diagnostic-functions #'package-lint-flymake))

#+end_src


*** The =bad-emacs-langs.el= settings for ~dictionary~
:PROPERTIES:
:CUSTOM_ID: h:f91563d8-f176-4555-b45b-ece56de03279
:END:

You can run your own dictionary server or access a webpage for
dictionary entries.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"

;; `dictionary'
(use-package dictionary
  :ensure nil
  :bind ("C-c d" . dictionary-search)
  :config
  (setq dictionary-server "dict.org"
        dictionary-default-popup-strategy "lev" ; read doc string
        dictionary-create-buttons nil
        dictionary-use-single-buffer t))

#+end_src


*** The =bad-emacs-langs.el= call of ~provide~

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-langs.el"
(provide 'bad-emacs-langs)
#+end_src


** The =bad-emacs-icons.el= module (~nerd-icons~ for various packages)
:PROPERTIES:
:CUSTOM_ID: h:4efde779-3ef0-40b7-82e4-70f71b321428
:END:

I like the icons and will install them. Remember that fonts are
not automatically installed by the packages. Use the command
~nerd-icons-install-fonts~.

#+begin_src emacs-lisp :tangle "bad-emacs-modules/bad-emacs-icons.el" :mkdirp yes
  ;; Icons

  (use-package nerd-icons
    :ensure t
    :after (dired ibuffer))

  (use-package nerd-icons-dired
    :ensure t
    :after (dired nerd-icons)
    :diminish
    :hook
    (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-ibuffer
    :ensure t
    :after (nerd-icons ibuffer)
    :diminish
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

  (use-package nerd-icons-completion
    :ensure t
    :after nerd-icons
    :diminish
    :config
    (declare-function nerd-icons-completion-mode "nerd-icons-completion")
    (nerd-icons-completion-mode)
    (declare-function nerd-icons-completion-marginalia-setup "nerd-icons-completion")
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

  (use-package nerd-icons-corfu
    :after (nerd-icons corfu)
    :ensure t
    :diminish)

  (provide 'bad-emacs-icons)
#+end_src


* The custom libraries of my configuration
:PROPERTIES:
:CUSTOM_ID: h:fc1ea247-5ef6-4c4e-a807-6c7b2482af90
:END:

Remember, Prot wrote these, not Troi.

I'm bringing most of them in, but will drop things like ~eww~
that I don't ever expect to use.

#+begin_quote
Each of the following subsections is dedicated to an individual
custom library. These are "packages" of mine that are only
relevant to my Emacs configuration, even though they are designed
in accordance with best practices for packaging Emacs Lisp code.
Many of my public-facing packages for Emacs started out as custom
libraries like these.
#+end_quote


** The =troi-abbrev.el= library
:PROPERTIES:
:CUSTOM_ID: h:ddb9c32c-2114-4347-9f76-5160e590b5dc
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-abbrev.el" :mkdirp yes
;;; troi-abbrev.el --- Functions for use with abbrev-mode -*- lexical-binding: t -*-

;; Copyright (C) 2024-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Functions for use with `abbrev-mode'.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup troi-abbrev ()
  "Functions for use with `abbrev-mode'."
  :group 'editing)

(defcustom troi-abbrev-time-specifier "%R"
  "Time specifier for `format-time-string'."
  :type 'string
  :group 'troi-abbrev)

(defcustom troi-abbrev-date-specifier "%F"
  "Date specifier for `format-time-string'."
  :type 'string
  :group 'troi-abbrev)

(defun troi-abbrev-current-time ()
  "Insert the current time per `troi-abbrev-time-specifier'."
  (insert (format-time-string troi-abbrev-time-specifier)))

(defun troi-abbrev-current-date ()
  "Insert the current date per `troi-abbrev-date-specifier'."
  (insert (format-time-string troi-abbrev-date-specifier)))

(defvar troi-abbrev-update-html-history nil
  "Minibuffer history for `troi-abbrev-update-html-prompt'.")

(defun troi-abbrev-update-html-prompt ()
  "Minibuffer prompt for `troi-abbrev-update-html'.
Use completion among previous entries, retrieving their data from
`troi-abbrev-update-html-history'."
  (completing-read
   "Insert update for manual: "
   troi-abbrev-update-html-history
   nil nil nil 'troi-abbrev-update-html-history))

(defun troi-abbrev-update-html ()
  "Insert message to update NAME.html page, by prompting for NAME."
  (insert (format "Update %s.html" (troi-abbrev-update-html-prompt))))

(provide 'troi-abbrev)
;;; troi-abbrev.el ends here
#+end_src


** The =troi-comment.el= library
:PROPERTIES:
:CUSTOM_ID: h:7affcbca-0808-4159-8eab-faa7973aefc7
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-comment.el" :mkdirp yes
;;; troi-comment.el --- Extensions newcomment.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my newcomment.el extras, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'newcomment)
(require 'troi-common)

(defgroup troi-comment ()
  "Extensions for newcomment.el."
  :group 'comment)

(defcustom troi-comment-keywords
  '("TODO" "NOTE" "TXB" "REVIEW" "BUG")
  "List of strings with keywords used by `troi-comment-timestamp-keyword'."
  :type '(repeat string)
  :group 'troi-comment)

(defcustom troi-comment-timestamp-format-concise "%F"
  "Specifier for date in `troi-comment-timestamp-keyword'.
Refer to the doc string of `format-time-string' for the available
options."
  :type 'string
  :group 'troi-comment)

(defcustom troi-comment-timestamp-format-verbose "%F %T %z"
  "Like `troi-comment-timestamp-format-concise', but longer."
  :type 'string
  :group 'troi-comment)

;;;###autoload
(defun troi-comment (n)
  "Comment N lines, defaulting to the current one.
When the region is active, comment its lines instead."
  (interactive "p")
  (if (use-region-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-line n)))

(make-obsolete 'troi-comment-comment-dwim 'troi-comment "2023-09-28")

(defvar troi-comment--keyword-hist '()
  "Minibuffer history of `troi-comment--keyword-prompt'.")

(defun troi-comment--keyword-prompt (keywords)
  "Prompt for candidate among KEYWORDS (per `troi-comment-timestamp-keyword')."
  (let ((def (car troi-comment--keyword-hist)))
    (completing-read
     (format "Select keyword [%s]: " def)
     keywords nil nil nil 'troi-comment--keyword-hist def)))

(defun troi-comment--format-date (verbose)
  "Format date using `format-time-string'.
VERBOSE has the same meaning as `troi-comment-timestamp-keyword'."
  (format-time-string
   (if verbose
       troi-comment-timestamp-format-verbose
     troi-comment-timestamp-format-concise)))

(defun troi-comment--timestamp (keyword &optional verbose)
  "Format string using current time and KEYWORD.
VERBOSE has the same meaning as `troi-comment-timestamp-keyword'."
  (format "%s %s: " keyword (troi-comment--format-date verbose)))

(defun troi-comment--format-comment (string)
  "Format comment STRING per `troi-comment-timestamp-keyword'.
STRING is a combination of a keyword and a time stamp."
  (concat comment-start
          (make-string comment-add (string-to-char comment-start))
          comment-padding
          string
          comment-end))

(defun troi-comment--maybe-newline ()
  "Call `newline' if current line is not empty.
Check `troi-comment-timestamp-keyword' for the rationale."
  (unless (troi-common-line-regexp-p 'empty 1)
    (save-excursion (newline))))

;;;###autoload
(defun troi-comment-timestamp-keyword (keyword &optional verbose)
  "Add timestamped comment with KEYWORD.

When called interactively, the list of possible keywords is that
of `troi-comment-keywords', though it is possible to input
arbitrary text.

If point is at the beginning of the line or if line is empty (no
characters at all or just indentation), the comment is started
there in accordance with `comment-style'.  Any existing text
after the point will be pushed to a new line and will not be
turned into a comment.

If point is anywhere else on the line and the line is not empty,
the comment is appended to the line with `comment-indent'.

The comment is always formatted as DELIMITER KEYWORD DATE:, with
the date format being controlled by the variable
`troi-comment-timestamp-format-concise'.  DELIMITER is the value
of `comment-start', as defined by the current major mode.

With optional VERBOSE argument (such as a prefix argument), use
an alternative date format, as specified by
`troi-comment-timestamp-format-verbose'."
  (interactive
   (list
    (troi-comment--keyword-prompt troi-comment-keywords)
    current-prefix-arg))
  (let ((string (troi-comment--timestamp keyword verbose))
        (beg (point)))
    (cond
     ((troi-common-line-regexp-p 'empty)
      (insert (troi-comment--format-comment string)))
     ((eq beg (line-beginning-position))
      (insert (troi-comment--format-comment string))
      (indent-region beg (point))
      (troi-comment--maybe-newline))
     (t
      (comment-indent t)
      (insert (concat " " string))))))

(provide 'troi-comment)
;;; troi-comment.el ends here
#+end_src


** The =troi-common.el= library
:PROPERTIES:
:CUSTOM_ID: h:3fccfadf-22e9-457f-b9fd-ed1b48600d23
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-common.el" :mkdirp yes
;;; troi-common.el --- Common functions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Common functions for my Emacs: <https://protesilaos.com/emacs/dotemacs/>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile
  (require 'subr-x)
  (require 'cl-lib))

(defgroup troi-common ()
  "Auxiliary functions for my dotemacs."
  :group 'editing)

;;;###autoload
(defun troi-common-number-even-p (n)
  "Test if N is an even number."
  (if (numberp n)
      (= (% n 2) 0)
    (error "%s is not a number" n)))

;;;###autoload
(defun troi-common-number-integer-p (n)
  "Test if N is an integer."
  (if (integerp n)
      n
    (error "%s is not an integer" n)))

;;;###autoload
(defun troi-common-number-integer-positive-p (n)
  "Test if N is a positive integer."
  (if (troi-common-number-integer-p n)
      (> n 0)
    (error "%s is not a positive integer" n)))

;; Thanks to Gabriel for providing a cleaner version of
;; `troi-common-number-negative': <https://github.com/gabriel376>.
;;;###autoload
(defun troi-common-number-negative (n)
  "Make N negative."
  (if (and (numberp n) (> n 0))
      (* -1 n)
    (error "%s is not a valid positive number" n)))

;;;###autoload
(defun troi-common-reverse-percentage (number percent change-p)
  "Determine the original value of NUMBER given PERCENT.

CHANGE-P should specify the increase or decrease.  For simplicity,
nil means decrease while non-nil stands for an increase.

NUMBER must satisfy `numberp', while PERCENT must be `natnump'."
  (unless (numberp number)
    (user-error "NUMBER must satisfy numberp"))
  (unless (natnump percent)
    (user-error "PERCENT must satisfy natnump"))
  (let* ((pc (/ (float percent) 100))
         (pc-change (if change-p (+ 1 pc) pc))
         (n (if change-p pc-change (float (- 1 pc-change)))))
    ;; FIXME 2021-12-21: If float, round to 4 decimal points.
    (/ number n)))

;;;###autoload
(defun troi-common-percentage-change (n-original n-final)
  "Find percentage change between N-ORIGINAL and N-FINAL numbers.

When the percentage is not an integer, it is rounded to 4
floating points: 16.666666666666664 => 16.667."
  (unless (numberp n-original)
    (user-error "N-ORIGINAL must satisfy numberp"))
  (unless (numberp n-final)
    (user-error "N-FINAL must satisfy numberp"))
  (let* ((difference (float (abs (- n-original n-final))))
         (n (* (/ difference n-original) 100))
         (round (floor n)))
    ;; FIXME 2021-12-21: Any way to avoid the `string-to-number'?
    (if (> n round) (string-to-number (format "%0.4f" n)) round)))

;; REVIEW 2023-04-07 07:43 +0300: I just wrote the conversions from
;; seconds.  Hopefully they are correct, but I need to double check.
(defun troi-common-seconds-to-minutes (seconds)
  "Convert a number representing SECONDS to MM:SS notation."
  (let ((minutes (/ seconds 60))
        (seconds (% seconds 60)))
    (format "%.2d:%.2d" minutes seconds)))

(defun troi-common-seconds-to-hours (seconds)
  "Convert a number representing SECONDS to HH:MM:SS notation."
  (let* ((hours (/ seconds 3600))
         (minutes (/ (% seconds 3600) 60))
         (seconds (% seconds 60)))
    (format "%.2d:%.2d:%.2d" hours minutes seconds)))

;;;###autoload
(defun troi-common-seconds-to-minutes-or-hours (seconds)
  "Convert SECONDS to either minutes or hours, depending on the value."
  (if (> seconds 3599)
      (troi-common-seconds-to-hours seconds)
    (troi-common-seconds-to-minutes seconds)))

;;;###autoload
(defun troi-common-rotate-list-of-symbol (symbol)
  "Rotate list value of SYMBOL by moving its car to the end.
Return the first element before performing the rotation.

This means that if `sample-list' has an initial value of `(one
two three)', this function will first return `one' and update the
value of `sample-list' to `(two three one)'.  Subsequent calls
will continue rotating accordingly."
  (unless (symbolp symbol)
    (user-error "%s is not a symbol" symbol))
  (when-let* ((value (symbol-value symbol))
              (list (and (listp value) value))
              (first (car list)))
    (set symbol (append (cdr list) (list first)))
    first))

;;;###autoload
(defun troi-common-empty-buffer-p ()
  "Test whether the buffer is empty."
  (or (= (point-min) (point-max))
      (save-excursion
        (goto-char (point-min))
        (while (and (looking-at "^\\([a-zA-Z]+: ?\\)?$")
                    (zerop (forward-line 1))))
        (eobp))))

;;;###autoload
(defun troi-common-minor-modes-active ()
  "Return list of active minor modes for the current buffer."
  (let ((active-modes))
    (mapc (lambda (m)
            (when (and (boundp m) (symbol-value m))
              (push m active-modes)))
          minor-mode-list)
    active-modes))

;;;###autoload
(defun troi-common-truncate-lines-silently ()
  "Toggle line truncation without printing messages."
  (let ((inhibit-message t))
    (toggle-truncate-lines t)))

;; NOTE 2023-08-12: I tried the `clear-message-function', but it did
;; not work.  What I need is very simple and this gets the job done.
;;;###autoload
(defun troi-common-clear-minibuffer-message (&rest _)
  "Print an empty message to clear the echo area.
Use this as advice :after a noisy function."
  (message ""))

;;;###autoload
(defun troi-common-disable-hl-line ()
  "Disable Hl-Line-Mode (for hooks)."
  ;; (hl-line-mode -1)
  )

;;;###autoload
(defun troi-common-window-bounds ()
  "Return start and end points in the window as a cons cell."
  (cons (window-start) (window-end)))

;;;###autoload
(defun troi-common-page-p ()
  "Return non-nil if there is a `page-delimiter' in the buffer."
  (or (save-excursion (re-search-forward page-delimiter nil t))
      (save-excursion (re-search-backward page-delimiter nil t))))

;;;###autoload
(defun troi-common-window-small-p ()
  "Return non-nil if window is small.
Check if the `window-width' or `window-height' is less than
`split-width-threshold' and `split-height-threshold',
respectively."
  (or (and (numberp split-width-threshold)
           (< (window-total-width) split-width-threshold))
      (and (numberp split-height-threshold)
           (> (window-total-height) split-height-threshold))))

(defun troi-common-window-narrow-p ()
  "Return non-nil if window is narrow.
Check if the `window-width' is less than `split-width-threshold'."
  (and (numberp split-width-threshold)
       (< (window-total-width) split-width-threshold)))

;;;###autoload
(defun troi-common-three-or-more-windows-p (&optional frame)
  "Return non-nil if three or more windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (>= (length (window-list frame :no-minibuffer)) 3))

;;;###autoload
(defun troi-common-read-data (file)
  "Read Elisp data from FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (read (current-buffer))))

;;;###autoload
(defun troi-common-completion-category ()
  "Return completion category."
  (when-let* ((window (active-minibuffer-window)))
    (with-current-buffer (window-buffer window)
      (completion-metadata-get
       (completion-metadata (buffer-substring-no-properties
                             (minibuffer-prompt-end)
                             (max (minibuffer-prompt-end) (point)))
                            minibuffer-completion-table
                            minibuffer-completion-predicate)
       'category))))

;; Thanks to Omar Antoln Camarena for providing this snippet!
;;;###autoload
(defun troi-common-completion-table (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.

This is intended for bespoke functions that need to pass
completion metadata that can then be parsed by other
tools (e.g. `embark')."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category))
      (complete-with-action action candidates string pred))))

;;;###autoload
(defun troi-common-completion-table-no-sort (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.
Like `troi-common-completion-table' but also disable sorting."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category)
                   (display-sort-function . ,#'identity))
      (complete-with-action action candidates string pred))))

;; Thanks to Igor Lima for the `troi-common-crm-exclude-selected-p':
;; <https://github.com/0x462e41>.
;; This is used as a filter predicate in the relevant prompts.
(defvar crm-separator)

;;;###autoload
(defun troi-common-crm-exclude-selected-p (input)
  "Filter out INPUT from `completing-read-multiple'.
Hide non-destructively the selected entries from the completion
table, thus avoiding the risk of inputting the same match twice.

To be used as the PREDICATE of `completing-read-multiple'."
  (if-let* ((pos (string-match-p crm-separator input))
            (rev-input (reverse input))
            (element (reverse
                      (substring rev-input 0
                                 (string-match-p crm-separator rev-input))))
            (flag t))
      (progn
        (while pos
          (if (string= (substring input 0 pos) element)
              (setq pos nil)
            (setq input (substring input (1+ pos))
                  pos (string-match-p crm-separator input)
                  flag (when pos t))))
        (not flag))
    t))

;; The `troi-common-line-regexp-p' and `troi-common--line-regexp-alist'
;; are contributed by Gabriel: <https://github.com/gabriel376>.  They
;; provide a more elegant approach to using a macro, as shown further
;; below.
(defvar troi-common--line-regexp-alist
  '((empty . "[\s\t]*$")
    (indent . "^[\s\t]+")
    (non-empty . "^.+$")
    (list . "^\\([\s\t#*+]+\\|[0-9]+[^\s]?[).]+\\)")
    (heading . "^[=-]+"))
  "Alist of regexp types used by `troi-common-line-regexp-p'.")

(defun troi-common-line-regexp-p (type &optional n)
  "Test for TYPE on line.
TYPE is the car of a cons cell in
`troi-common--line-regexp-alist'.  It matches a regular
expression.

With optional N, search in the Nth line from point."
  (save-excursion
    (goto-char (line-beginning-position))
    (and (not (bobp))
         (or (beginning-of-line n) t)
         (save-match-data
           (looking-at
            (alist-get type troi-common--line-regexp-alist))))))

;; The `troi-common-shell-command-with-exit-code-and-output' function is
;; courtesy of Harold Carr, who also sent a patch that improved
;; `troi-eww-download-html' (from the `troi-eww.el' library).
;;
;; More about Harold: <http://haroldcarr.com/about/>.
(defun troi-common-shell-command-with-exit-code-and-output (command &rest args)
  "Run COMMAND with ARGS.
Return the exit code and output in a list."
  (with-temp-buffer
    (list (apply 'call-process command nil (current-buffer) nil args)
          (buffer-string))))

(defvar troi-common-url-regexp
  (concat
   "~?\\<\\([-a-zA-Z0-9+&@#/%?=~_|!:,.;]*\\)"
   "[.@]"
   "\\([-a-zA-Z0-9+&@#/%?=~_|!:,.;]+\\)\\>/?")
  "Regular expression to match (most?) URLs or email addresses.")

(autoload 'auth-source-search "auth-source")

;;;###autoload
(defun troi-common-auth-get-field (host prop)
  "Find PROP in `auth-sources' for HOST entry."
  (when-let* ((source (auth-source-search :host host)))
    (if (eq prop :secret)
        (funcall (plist-get (car source) prop))
      (plist-get (flatten-list source) prop))))

;;;###autoload
(defun troi-common-parse-file-as-list (file)
  "Return the contents of FILE as a list of strings.
Strings are split at newline characters and are then trimmed for
negative space.

Use this function to provide a list of candidates for
completion (per `completing-read')."
  (split-string
   (with-temp-buffer
     (insert-file-contents file)
     (buffer-substring-no-properties (point-min) (point-max)))
   "\n" :omit-nulls "[\s\f\t\n\r\v]+"))

(defun troi-common-ignore (&rest _)
  "Use this as override advice to make a function do nothing."
  nil)

;; NOTE 2023-06-02: The `troi-common-wcag-formula' and
;; `troi-common-contrast' are taken verbatim from my `modus-themes'
;; and renamed to have the prefix `troi-common-' instead of
;; `modus-themes-'.  This is all my code, of course, but I do it this
;; way to ensure that this file is self-contained in case someone
;; copies it.

;; This is the WCAG formula: <https://www.w3.org/TR/WCAG20-TECHS/G18.html>.
(defun troi-common-wcag-formula (hex)
  "Get WCAG value of color value HEX.
The value is defined in hexadecimal RGB notation, such #123456."
  (cl-loop for k in '(0.2126 0.7152 0.0722)
           for x in (color-name-to-rgb hex)
           sum (* k (if (<= x 0.03928)
                        (/ x 12.92)
                      (expt (/ (+ x 0.055) 1.055) 2.4)))))

;;;###autoload
(defun troi-common-contrast (c1 c2)
  "Measure WCAG contrast ratio between C1 and C2.
C1 and C2 are color values written in hexadecimal RGB."
  (let ((ct (/ (+ (troi-common-wcag-formula c1) 0.05)
               (+ (troi-common-wcag-formula c2) 0.05))))
    (max ct (/ ct))))

;;;; EXPERIMENTAL macros (not meant to be used anywhere)

;; TODO 2023-09-30: Try the same with `cl-defmacro' and &key
(defmacro troi-common-if (condition &rest consequences)
  "Separate the CONSEQUENCES of CONDITION semantically.
Like `if', `when', `unless' but done by using `:then' and `:else'
keywords.  The forms under each keyword of `:then' and `:else'
belong to the given subset of CONSEQUENCES.

- The absence of `:else' means: (if CONDITION (progn CONSEQUENCES)).
- The absence of `:then' means: (if CONDITION nil CONSEQUENCES).
- Otherwise: (if CONDITION (progn then-CONSEQUENCES) else-CONSEQUENCES)."
  (declare (indent 1))
  (let (then-consequences else-consequences last-kw)
    (dolist (elt consequences)
      (let ((is-keyword (keywordp elt)))
        (cond
         ((and (not is-keyword) (eq last-kw :then))
          (push elt then-consequences))
         ((and (not is-keyword) (eq last-kw :else))
          (push elt else-consequences))
         ((and is-keyword (eq elt :then))
          (setq last-kw :then))
         ((and is-keyword (eq elt :else))
          (setq last-kw :else)))))
    `(if ,condition
         ,(if then-consequences
              `(progn ,@(nreverse then-consequences))
            nil)
       ,@(nreverse else-consequences))))

(provide 'troi-common)
;;; troi-common.el ends here
#+end_src


** The =troi-dired.el= library
:PROPERTIES:
:CUSTOM_ID: h:92cfefcf-8c20-43cd-b47c-ffe0c5fe1887
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-dired.el" :mkdirp yes
;;; troi-dired.el --- Extensions to dired.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my dired.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'troi-common)
(require 'dired)
(require 'dired-aux)

(defgroup troi-dired ()
  "Extensions for Dired."
  :group 'dired)

;;;; Flat Dired listing

(defvar troi-dired-regexp-history nil
  "Minibuffer history of `troi-dired-regexp-prompt'.")

(defun troi-dired-regexp-prompt ()
  (let ((default (car troi-dired-regexp-history)))
    (read-regexp
     (format-prompt "Files matching REGEXP" default)
     default 'troi-dired-regexp-history)))

(defun troi-dired--get-files (regexp)
  "Return files matching REGEXP, recursively from `default-directory'."
  (directory-files-recursively default-directory regexp nil))

;;;###autoload
(defun troi-dired-search-flat-list (regexp)
  "Return a Dired buffer for files matching REGEXP.
Perform the search recursively from the current directory."
  (interactive (list (troi-dired-regexp-prompt)))
  (if-let* ((files (troi-dired--get-files regexp))
            (relative-paths (mapcar #'file-relative-name files)))
      (dired (cons (format "troi-flat-dired for `%s'" regexp) relative-paths))
    (error "No files matching `%s'" regexp)))

;;;; General commands

;; NOTE 2023-06-27: This user option is quick-and-dirty.  I prefer not
;; to have an option at all and simply do the right thing based on
;; `dired-guess-shell-alist-user'.
(defcustom troi-dired-always-external-regexp
  "\\(mkv\\|mp4\\|mp4\\|ogg\\|m4a\\|webm\\)"
  "Regular expression of file extensions to open externally.
The test is performed by `troi-dired-open-dwim', which then
defers to the `dired-guess-shell-alist-user'."
  :group 'troi-dired
  :type 'string)

;; NOTE 2023-06-27: This is a proof-of-concept.  See the previous
;; note.
(defun troi-dired-open-dwim (files)
  "Open FILES using the appropriate program."
  (interactive (list (dired-get-marked-files)))
  (if-let* ((extension (file-name-extension (car files)))
            ((string-match-p extension troi-dired-always-external-regexp))
            (guess (dired-guess-default files))
            (program (if (listp guess) (car guess) guess)))
      (dired-do-async-shell-command program nil files)
    (find-file (car files))))

(defvar troi-dired--limit-hist '()
  "Minibuffer history for `troi-dired-limit-regexp'.")

;;;###autoload
(defun troi-dired-limit-regexp (regexp omit)
  "Limit Dired to keep files matching REGEXP.

With optional OMIT argument as a prefix (\\[universal-argument]),
exclude files matching REGEXP.

Restore the buffer with \\<dired-mode-map>`\\[revert-buffer]'."
  (interactive
   (list
    (read-regexp
     (concat "Files "
             (when current-prefix-arg
               (propertize "NOT " 'face 'warning))
             "matching PATTERN: ")
     nil 'troi-dired--limit-hist)
    current-prefix-arg))
  (dired-mark-files-regexp regexp)
  (unless omit (dired-toggle-marks))
  (dired-do-kill-lines)
  (add-to-history 'troi-dired--limit-hist regexp))

(defvar troi-dired--find-grep-hist '()
  "Minibuffer history for `troi-dired-grep-marked-files'.")

;; Also see `troi-search-grep' from troi-search.el.
;;;###autoload
(defun troi-dired-grep-marked-files (regexp &optional arg)
  "Run `find' with `grep' for REGEXP on marked files.
When no files are marked or when just a single one is marked,
search the entire directory instead.

With optional prefix ARG target a single marked file.

We assume that there is no point in marking a single file and
running find+grep on its contents.  Visit it and call `occur' or
run grep directly on it without the whole find part."
  (interactive
   (list
    (read-string "grep for PATTERN (marked files OR current directory): " nil 'troi-dired--find-grep-hist)
    current-prefix-arg)
   dired-mode)
  (when-let* ((marks (dired-get-marked-files 'no-dir))
              (files (mapconcat #'identity marks " "))
              (args (if (or arg (length> marks 1))
                        ;; Thanks to Sean Whitton for pointing out an
                        ;; earlier superfluity of mine: we do not need
                        ;; to call grep through find when we already
                        ;; know the files we want to search in.  Check
                        ;; Sean's dotfiles:
                        ;; <https://git.spwhitton.name/dotfiles>.
                        ;;
                        ;; Any other errors or omissions are my own.
                        (format "grep -nH --color=auto %s %s" (shell-quote-argument regexp) files)
                      (concat
                       "find . -not " (shell-quote-argument "(")
                       " -wholename " (shell-quote-argument "*/.git*")
                       " -prune " (shell-quote-argument ")")
                       " -type f"
                       " -exec grep -nHE --color=auto " regexp " "
                       (shell-quote-argument "{}")
                       " " (shell-quote-argument ";") " "))))
    (compilation-start
     args
     'grep-mode
     (lambda (mode) (format "*troi-dired-find-%s for '%s'" mode regexp))
     t)))

;;;; Subdir extras and Imenu setup

(defvar troi-dired--directory-header-regexp "^ +\\(.+\\):\n"
  "Pattern to match Dired directory headings.")

;;;###autoload
(defun troi-dired-subdirectory-next (&optional arg)
  "Move to next or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((pos (point))
        (subdir troi-dired--directory-header-regexp))
    (goto-char (line-end-position))
    (if (re-search-forward subdir nil t (or arg nil))
        (progn
          (goto-char (match-beginning 1))
          (goto-char (line-beginning-position)))
      (goto-char pos))))

;;;###autoload
(defun troi-dired-subdirectory-previous (&optional arg)
  "Move to previous or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((pos (point))
        (subdir troi-dired--directory-header-regexp))
    (goto-char (line-beginning-position))
    (if (re-search-backward subdir nil t (or arg nil))
        (goto-char (line-beginning-position))
      (goto-char pos))))

(autoload 'dired-current-directory "dired")
(autoload 'dired-kill-subdir "dired-aux")

;;;###autoload
(defun troi-dired-remove-inserted-subdirs ()
  "Remove all inserted Dired subdirectories."
  (interactive)
  (goto-char (point-max))
  (while (and (troi-dired-subdirectory-previous)
              (not (equal (dired-current-directory)
                          (expand-file-name default-directory))))
    (dired-kill-subdir)))

(autoload 'cl-remove-if-not "cl-seq")

(defun troi-dired--dir-list (list)
  "Filter out non-directory file paths in LIST."
  (cl-remove-if-not
   (lambda (dir)
     (file-directory-p dir))
   list))

(defun troi-dired--insert-dir (dir &optional flags)
  "Insert DIR using optional FLAGS."
  (dired-maybe-insert-subdir (expand-file-name dir) (or flags nil)))

(autoload 'dired-get-filename "dired")
(autoload 'dired-get-marked-files "dired")
(autoload 'dired-maybe-insert-subdir "dired-aux")
(defvar dired-subdir-switches)
(defvar dired-actual-switches)

;;;###autoload
(defun troi-dired-insert-subdir (&optional arg)
  "Generic command to insert subdirectories in Dired buffers.

When items are marked, insert those which are subsirectories of
the current directory.  Ignore regular files.

If no marks are active and point is on a subdirectory line,
insert it directly.

If no marks are active and point is not on a subdirectory line,
prompt for a subdirectory using completion.

With optional ARG as a single prefix (`\\[universal-argument]')
argument, prompt for command line flags to pass to the underlying
ls program.

With optional ARG as a double prefix argument, remove all
inserted subdirectories."
  (interactive "p")
  (let* ((name (dired-get-marked-files))
         (flags (when (eq arg 4)
                  (read-string "Flags for `ls' listing: "
                               (or dired-subdir-switches dired-actual-switches)))))
    (cond  ; NOTE 2021-07-20: `length>', `length=' are from Emacs28
     ((eq arg 16)
      (troi-dired-remove-inserted-subdirs))
     ((and (length> name 1) (troi-dired--dir-list name))
      (mapc (lambda (file)
              (when (file-directory-p file)
                (troi-dired--insert-dir file flags)))
            name))
     ((and (length= name 1) (file-directory-p (car name)))
      (troi-dired--insert-dir (car name) flags))
     (t
      (let ((selection (read-directory-name "Insert directory: ")))
        (troi-dired--insert-dir selection flags))))))

(defun troi-dired--imenu-prev-index-position ()
  "Find the previous file in the buffer."
  (let ((subdir troi-dired--directory-header-regexp))
    (re-search-backward subdir nil t)))

(defun troi-dired--imenu-extract-index-name ()
  "Return the name of the file at point."
  (file-relative-name
   (buffer-substring-no-properties (+ (line-beginning-position) 2)
                                   (1- (line-end-position)))))

;;;###autoload
(defun troi-dired-setup-imenu ()
  "Configure imenu for the current Dired buffer.
Add this to `dired-mode-hook'."
  (set (make-local-variable 'imenu-prev-index-position-function)
       'troi-dired--imenu-prev-index-position)
  (set (make-local-variable 'imenu-extract-index-name-function)
       'troi-dired--imenu-extract-index-name))

(provide 'troi-dired)
;;; troi-dired.el ends here
#+end_src


** The =troi-embark.el= library
:PROPERTIES:
:CUSTOM_ID: h:fb034be5-c316-4c4f-a46f-cebcab332a47
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-embark.el" :mkdirp yes
;;; troi-embark.el --- Custom Embark keymaps -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1") (embark "0.23"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'embark)

(defvar-keymap troi-embark-general-map
  :parent embark-general-map
  "i" #'embark-insert
  "w" #'embark-copy-as-kill
  "E" #'embark-export
  "S" #'embark-collect
  "A" #'embark-act-all
  "DEL" #'delete-region)

(defvar-keymap troi-embark-url-map
  :parent embark-general-map
  "b" #'browse-url
  "d" #'embark-download-url
  "e" #'eww)

(defvar-keymap troi-embark-buffer-map
  :parent embark-general-map
  "k" #'troi-simple-kill-buffer
  "o" #'switch-to-buffer-other-window
  "e" #'ediff-buffers)

(add-to-list 'embark-post-action-hooks (list 'troi-simple-kill-buffer 'embark--restart))

(defvar-keymap troi-embark-file-map
  :parent embark-general-map
  "f" #'find-file
  "j" #'embark-dired-jump
  "c" #'copy-file
  "e" #'ediff-files)

(defvar-keymap troi-embark-identifier-map
  :parent embark-general-map
  "h" #'display-local-help
  "." #'xref-find-definitions
  "o" #'occur)

(defvar-keymap troi-embark-command-map
  :parent embark-general-map
  "h" #'describe-command
  "." #'embark-find-definition)

(defvar-keymap troi-embark-expression-map
  :parent embark-general-map
  "e" #'pp-eval-expression
  "m" #'pp-macroexpand-expression)

(defvar-keymap troi-embark-function-map
  :parent embark-general-map
  "h" #'describe-function
  "." #'embark-find-definition)

(defvar-keymap troi-embark-package-map
  :parent embark-general-map
  "h" #'describe-package
  "i" #'package-install
  "d" #'package-delete
  "r" #'package-reinstall
  "u" #'embark-browse-package-url
  "w" #'embark-save-package-url)

(defvar-keymap troi-embark-symbol-map
  :parent embark-general-map
  "h" #'describe-symbol
  "." #'embark-find-definition)

(defvar-keymap troi-embark-variable-map
  :parent embark-general-map
  "h" #'describe-variable
  "." #'embark-find-definition)

(defvar-keymap troi-embark-region-map
  :parent embark-general-map
  "a" #'align-regexp
  "D" #'delete-duplicate-lines
  "f" #'flush-lines
  "i" #'epa-import-keys-region
  "d" #'epa-decrypt-armor-in-region
  "r" #'repunctuate-sentences
  "s" #'sort-lines
  "u" #'untabify)

;; The minimal indicator shows cycling options, but I have no use
;; for those.  I want it to be silent.
(defun troi-embark-no-minimal-indicator ())
(advice-add #'embark-minimal-indicator :override #'troi-embark-no-minimal-indicator)

(defun troi-embark-act-no-quit ()
  "Call `embark-act' but do not quit after the action."
  (interactive)
  (let ((embark-quit-after-action nil))
    (call-interactively #'embark-act)))

(defun troi-embark-act-quit ()
  "Call `embark-act' and quit after the action."
  (interactive)
  (let ((embark-quit-after-action t))
    (call-interactively #'embark-act))
  (when (and (> (minibuffer-depth) 0)
             (derived-mode-p 'completion-list-mode))
    (abort-recursive-edit)))

(provide 'troi-embark)
;;; troi-embark.el ends here
#+end_src


** The =troi-marginalia.el= library
:PROPERTIES:
:CUSTOM_ID: h:92085a6d-213f-400d-be83-763eb80a3877
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-marginalia.el" :mkdirp yes
;;; troi-marginalia.el --- Code for my custom mode line -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'bookmark)
(require 'package)

(defun troi-marginalia-truncate (string)
  "Truncate STRING to `fill-column', if necessary."
  (if (> (length string) fill-column)
      (concat (substring string 0 fill-column) "...")
    string))

(defun troi-marginalia-display (string)
  "Propertize the display of STRING for completion annotation purposes."
  (when (stringp string)
    (format "%s%s"
            (propertize " " 'display `(space :align-to 40))
            (propertize (troi-marginalia-truncate string)
                        'face 'completions-annotations))))

(defun troi-marginalia-bookmark (bookmark)
  "Annotate BOOKMARK with its file path."
  (when-let* ((bm (assoc bookmark (bound-and-true-p bookmark-alist)))
              (path (bookmark-get-filename bookmark)))
    (troi-marginalia-display path)))

(defun troi-marginalia-buffer (buffer)
  "Annotate BUFFER with the return value of function `buffer-file-name'."
  (if-let* ((name (buffer-file-name (get-buffer buffer))))
      (troi-marginalia-display (abbreviate-file-name name))
    (troi-marginalia-display (format "%s" (buffer-local-value 'major-mode (get-buffer buffer))))))

(defun troi-marginalia-package (package)
  "Annotate PACKAGE with its summary."
  (when-let* ((pkg-alist (bound-and-true-p package-alist))
              (pkg (intern-soft package))
              (desc (or (when (package-desc-p pkg) pkg)
                        (car (alist-get pkg pkg-alist))
                        (if-let* ((built-in (assq pkg package--builtins)))
                            (package--from-builtin built-in)
                          (car (alist-get pkg package-archive-contents))))))
    (troi-marginalia-display (package-desc-summary desc))))

(defun troi-marginalia--get-symbol-doc (symbol)
  "Return documentation string according to SYMBOL type."
  (cond
   ((or (functionp symbol) (macrop symbol))
    (documentation symbol))
   (t
    (get symbol 'variable-documentation))))

(defun troi-marginalia--first-line-documentation (symbol)
  "Return first line of SYMBOL documentation string."
  (when-let* ((doc-string (troi-marginalia--get-symbol-doc symbol))
              ((stringp doc-string))
              ((not (string-empty-p doc-string))))
    (car (split-string doc-string "[?!.\n]"))))

(defun troi-marginalia-symbol (symbol)
  "Annotate SYMBOL with its documentation string."
  (when-let* ((sym (intern-soft symbol))
              (doc-string (troi-marginalia--first-line-documentation sym)))
    (troi-marginalia-display doc-string)))

(provide 'troi-marginalia)
;;; troi-marginalia.el ends here
#+end_src


** The =troi-orderless.el= library
:PROPERTIES:
:CUSTOM_ID: h:114c6e8c-697a-43e9-8fd9-52872997e1c9
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-orderless.el" :mkdirp yes
;;; troi-orderless.el --- Extensions for Orderless -*- lexical-binding: t -*-

;; Copyright (C) 2020-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Extensions for the Orderless completion style for use in my Emacs
;; setup: <https://protesilaos.com/emacs/dotemacs/>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

;;;; Style dispatchers

(defun troi-orderless-literal (word _index _total)
  "Read WORD= as a literal string."
  (when (string-suffix-p "=" word)
    ;; The `orderless-literal' is how this should be treated by
    ;; orderless.  The `substring' form omits the `=' from the
    ;; pattern.
    `(orderless-literal . ,(substring word 0 -1))))

(defun troi-orderless-file-ext (word _index _total)
  "Expand WORD. to a file suffix when completing file names."
  (when (and minibuffer-completing-file-name
             (string-suffix-p "." word))
    `(orderless-regexp . ,(format "\\.%s\\'" (substring word 0 -1)))))

(defun troi-orderless-beg-or-end (word _index _total)
  "Expand WORD~ to \\(^WORD\\|WORD$\\)."
  (when-let* (((string-suffix-p "~" word))
              (word (substring word 0 -1)))
    `(orderless-regexp . ,(format "\\(^%s\\|%s$\\)" word word))))

(provide 'troi-orderless)
;;; troi-orderless.el ends here
#+end_src


** The =troi-org.el= library
:PROPERTIES:
:CUSTOM_ID: h:9974eac8-2167-45c4-90e0-12dd877403da
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-org.el" :mkdirp yes
;;; troi-org.el --- Tweaks for my org-mode configurations -*- lexical-binding: t -*-

;; Copyright (C) 2021-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my tweaks for Org that are meant for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'troi-common)
(require 'org)

(defgroup troi-org ()
  "Extensions for org.el."
  :group 'org)

;;;; org-capture

(declare-function cl-letf "cl-lib")

;; Adapted from source: <https://stackoverflow.com/a/54251825>.
;;
;; Thanks to Juanjo Presa (@uningan on GitHub) for discovering that the
;; original version was causing an error in `org-roam'.  I then figure
;; we were missing the `&rest':
;; <https://github.com/org-roam/org-roam/issues/2142#issuecomment-1100718373>.
(defun troi-org--capture-no-delete-windows (&rest args)
  "Apply ARGS while ignoring `delete-other-windows'."
  (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
    (apply args)))

;; Same source as above
(advice-add 'org-capture-place-template :around 'troi-org--capture-no-delete-windows)
(advice-add 'org-add-log-note :around 'troi-org--capture-no-delete-windows)

;;;;; Custom function to select a project to add to

(defun troi-org--get-outline (&optional file)
  "Return `outline-regexp' headings and line numbers of current file or FILE."
  (with-current-buffer (find-file-noselect file)
    (let ((outline-regexp (format "^\\(?:%s\\)" (or (bound-and-true-p outline-regexp) "[*\^L]+")))
          candidates)
      (save-excursion
        (goto-char (point-min))
        (while (if (bound-and-true-p outline-search-function)
                   (funcall outline-search-function)
                 (re-search-forward outline-regexp nil t))
          (push
           ;; NOTE 2024-11-24: The -5 (minimum width) is a sufficiently high number to keep the
           ;; alignment consistent in most cases.  Larger files will simply shift the heading text
           ;; in minibuffer, but this is not an issue anymore.
           (format "%-5s\t%s"
                   (line-number-at-pos (point))
                   (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
           candidates)
          (goto-char (1+ (line-end-position)))))
      (if candidates
          (nreverse candidates)
        (user-error "No outline")))))

(defvar troi-org-outline-history nil
  "Minibuffer history for `troi-org-outline-prompt'.")

(defun troi-org-outline-prompt (&optional file)
  "Prompt for outline among headings retrieved by `troi-org--get-outline'.
With optional FILE use the outline of it, otherwise use that of
the current file."
  (let ((current-file (or file buffer-file-name))
        (default (car troi-org-outline-history)))
    (completing-read
     (format-prompt
      (format "Select heading inside `%s': "
              (propertize (file-name-nondirectory current-file) 'face 'error))
      default)
     (troi-common-completion-table-no-sort 'imenu (troi-org--get-outline current-file))
     nil :require-match nil 'troi-org-outline-history default)))

(defvar troi-org-file-history nil
  "Minibuffer history of `troi-org-file-prompt'.")

(defun troi-org--not-useful-p (file)
  "Return non-nil if FILE is not a useful Org file for `org-capture'."
  (or (string-match-p "\\.org_archive\\'" file)
      (backup-file-name-p file)
      (not (string-match-p "\\.org\\'" file))))

(defun troi-org-file-prompt ()
  "Select a file in the `org-directory'."
  (if-let* ((dir org-directory)
            (files (directory-files-recursively org-directory ".*" nil))
            (files (seq-remove #'troi-org--not-useful-p files)))
      (let ((default (car troi-org-file-history)))
        (completing-read
         (format-prompt "Select file" default)
         (troi-common-completion-table 'file files)
         nil :require-match nil 'troi-org-file-history default))
    (user-error "There are no files in the `org-directory'")))

;;;###autoload
(defun troi-org-select-heading-in-file ()
  "Like `troi-org-select-project' but specifically for `org-capture'."
  (declare (interactive-only t))
  (interactive)
  (pcase-let* ((file (troi-org-file-prompt))
               (line-with-heading (troi-org-outline-prompt file))
               (`(,line ,text) (split-string line-with-heading "\t"))
               (line (string-to-number line)))
    ;; NOTE 2024-11-24: `with-current-buffer' does not work with `org-capture'.
    (find-file file)
    (goto-char (point-min))
    (forward-line (1- line))))

(defalias 'troi-org-goto-heading-in-file 'troi-org-select-heading-in-file
 "Alias for `troi-org-select-heading-in-file'.")

;;;; Org clock report

(defvar troi-org-clock--template-with-effort
  "#+BEGIN: clocktable :formula % :properties (\"Effort\") :timestamp t :sort (1 . ?a) :link t :scope nil :hidefiles t :maxlevel 8 :stepskip0 t
,#+END:"
  "Clock table with effort estimate column to use for custom clock reports.")

(defvar troi-org-clock--template-no-effort
  "#+BEGIN: clocktable :formula % :timestamp t :sort (1 . ?a) :link nil :scope nil :hidefiles t :maxlevel 8 :stepskip0 t
,#+END:"
  "Clock table to use for custom clock reports.")

(defvar troi-org-clock--ranges
  '( today yesterday thisweek lastweek thismonth
     lastmonth thisyear lastyear untilnow)
  "Time ranges of my interest for clock reports.")

(defvar troi-org-clock--report-range-history nil
  "Minibuffer history for `troi-org-clock--report-range-prompt'.")

(defun troi-org-clock--report-range-prompt ()
  "Prompt for a clock table range among `troi-org-clock--ranges'."
  (let ((default (car troi-org-clock--report-range-history)))
    (completing-read
     (format-prompt "Select a time range for the clock" default)
     troi-org-clock--ranges nil :require-match nil 'troi-org-clock--report-range-history
     default)))

(defun troi-org-clock--get-report (scope)
  "Produce clock report with current file SCOPE and return its buffer.
SCOPE is a symbol of either `file' or `subtree'.  If the former, then
use the entire file's contents.  Else use those of the current subtree."
  (let ((buffer (get-buffer-create "*troi-org-custom-clock-report*")))
    (save-restriction
      (unwind-protect
          (progn
            (pcase scope
              ('file nil)
              ('subtree (org-narrow-to-subtree))
              (_ (error "The scope `%s' is unknown" scope)))
            (let ((contents (buffer-substring (point-min) (point-max))))
              (with-current-buffer buffer
                (erase-buffer)
                (org-mode)
                (save-excursion
                  (insert (format "%s\n\n" troi-org-clock--template-with-effort))
                  (insert contents))
                (save-excursion
                  (let ((range (troi-org-clock--report-range-prompt)))
                    (goto-char (line-end-position))
                    (insert (concat " :block " range))))
                (org-dblock-update))))
        (widen)))
    buffer))

;;;###autoload
(defun troi-org-clock-report-current-subtree-or-file (&optional whole-buffer)
  "Produce a clock report in a new buffer for the subtree at point.
With optional WHOLE-BUFFER as a non-nil value, operate on the entire file.
When called interactively WHOLE-BUFFER is a prefix argument."
  (interactive "P")
  (when-let* ((buffer (troi-org-clock--get-report (if whole-buffer 'file 'subtree))))
    (pop-to-buffer buffer)))

;;;###autoload
(defun troi-org-clock-select-heading-and-clock-report ()
  "Select a heading in a file and do a clock report for it in a new buffer."
  (interactive)
  (call-interactively 'troi-org-select-heading-in-file)
  (call-interactively 'troi-org-clock-report-current-subtree-or-file))

;;;;; Coaching-related Org custom clocking

;; TODO 2024-12-15: This sort of thing must exist in Org, but I did
;; not find it.
(defun troi-org--timestamp-to-time (string)
  "Return time object of STRING timestamp."
  (org-timestamp-to-time (org-timestamp-from-string string)))

(defun troi-org-coach--get-entries (todo-keyword string since)
  "Get Org entries matching TODO-KEYWORD followed by STRING in the heading.
Limit entries to those whole deadline/scheduled is equal or greater to
SINCE date.

Each entry is a plist of :heading, :contents, :started, :closed."
  (or (delq nil
            (org-map-entries
             (lambda ()
               (when-let* ((case-fold-search t)
                           (started (troi-org--timestamp-to-time (or (org-entry-get nil "DEADLINE") (org-entry-get nil "SCHEDULED"))))
                           (closed (troi-org--timestamp-to-time (org-entry-get nil "CLOSED")))
                           ((re-search-forward (format "\\<%s\\>.*\\<%s\\>" todo-keyword string) (line-end-position) t 1))
                           ((org-time-less-p since started)))
                 (list
                  :heading (org-get-heading :no-tags :no-todo :no-priority :no-comment)
                  :contents (org-get-entry)
                  :started started
                  :closed closed)))))
      (user-error "No entries with heading matching `\\<%s\\>.*\\<%s\\>'" todo-keyword string)))

(defvar troi-org-coach--name-history nil
  "Minibuffer history of `troi-org-coach--name-prompt'.")

(defun troi-org-coach--name-prompt ()
  "Prompt for name of person."
  (let ((default (car troi-org-coach--name-history)))
    (read-string
     (format-prompt "Name of person" default)
     nil 'troi-org-coach--name-history default)))

;;;###autoload
(defun troi-org-coach-report (name since)
  "Produce clock report for coaching with person of NAME.
SINCE is the date (of time 00:00) to count from until now."
  (interactive
   (list
    (troi-org-coach--name-prompt)
    (format "[%s]" (org-read-date))))
  (if-let* ((since-object (troi-org--timestamp-to-time since))
            (entries (troi-org-coach--get-entries "done" name since-object))
            (buffer (get-buffer-create "*troi-org-coach-entries*")))
      (with-current-buffer (pop-to-buffer buffer)
        (erase-buffer)
        (org-mode)
        (dolist (entry entries)
          (insert (format "* %s\n%s\n\n" (plist-get entry :heading) (plist-get entry :contents)))
          (org-clock-in nil (plist-get entry :started))
          (org-clock-out nil t (plist-get entry :closed)))
        (goto-char (point-min))
        (save-excursion
          (insert (format "%s\n\n" troi-org-clock--template-no-effort)))
        (save-excursion
          (goto-char (line-end-position))
          (insert (format " :tstart %S" since)))
        (org-dblock-update))
    (user-error "No entries for name `%s'" name)))

;;;; org-agenda

(declare-function calendar-day-name "calendar")
(declare-function calendar-day-of-week "calendar")
(declare-function calendar-month-name "calendar")
(declare-function org-days-to-iso-week "org")
(declare-function calendar-absolute-from-gregorian "calendar")

(defvar org-agenda-format-date)

;;;###autoload
(defun troi-org-agenda-format-date-aligned (date)
  "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading.

Slightly tweaked version of `org-agenda-format-date-aligned' that
produces dates with a fixed length."
  (require 'cal-iso)
  (let* ((dayname (calendar-day-name date t))
         (day (cadr date))
         (day-of-week (calendar-day-of-week date))
         (month (car date))
         (monthname (calendar-month-name month t))
         (year (nth 2 date))
         (iso-week (org-days-to-iso-week
                    (calendar-absolute-from-gregorian date)))
         ;; (weekyear (cond ((and (= month 1) (>= iso-week 52))
         ;;                  (1- year))
         ;;                 ((and (= month 12) (<= iso-week 1))
         ;;                  (1+ year))
         ;;                 (t year)))
         (weekstring (if (= day-of-week 1)
                         (format " (W%02d)" iso-week)
                       "")))
    (format "%s %2d %s %4d%s"
            dayname day monthname year weekstring)))

(defvar org-priority-highest)

(defun troi-org-agenda-include-priority-no-timestamp ()
  "Return nil if heading has a priority but no timestamp.
Otherwise, return the buffer position from where the search should
continue, per `org-agenda-skip-function'."
  (let ((point (point)))
    (if (and (eq (nth 3 (org-heading-components)) ?A)
             (not (org-get-deadline-time point))
             (not (org-get-scheduled-time point)))
        nil
      (line-beginning-position 2))))

(defvar troi-org-custom-daily-agenda
  ;; NOTE 2021-12-08: Specifying a match like the following does not
  ;; work.
  ;;
  ;; tags-todo "+PRIORITY=\"A\""
  ;;
  ;; So we match everything and then skip entries with
  ;; `org-agenda-skip-function'.
  `((tags-todo "*"
               ((org-agenda-overriding-header "Important tasks without a date\n")
                ;; NOTE 2024-10-31: Those used to work, but now the
                ;; query for the timestamp is ignored.  I thus wrote
                ;; `troi-org-agenda-include-priority-no-timestamp'.
                ;;
                ;; (org-agenda-skip-function '(org-agenda-skip-subtree-if nil '(timestamp)))
                ;; (org-agenda-skip-function
                ;;  `(org-agenda-skip-entry-if
                ;;    'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                (org-agenda-skip-function #'troi-org-agenda-include-priority-no-timestamp)
                (org-agenda-block-separator nil)))
    (agenda "" ((org-agenda-overriding-header "\nPending scheduled tasks")
                (org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                (org-agenda-span 1)
                (org-agenda-show-all-dates nil)
                (org-scheduled-past-days 365)
                ;; Excludes today's scheduled items
                (org-scheduled-delay-days 1)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:scheduled))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "ROUTINE"))
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "")))
    (agenda "" ((org-agenda-overriding-header "\nToday's agenda\n")
                (org-agenda-span 1)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-scheduled-past-days 0)
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "ROUTINE"))
                ;; We don't need the `org-agenda-date-today'
                ;; highlight because that only has a practical
                ;; utility in multi-day views.
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "%A %-e %B %Y")))
    ;; (agenda "" ((org-agenda-overriding-header "\nRoutine")
    ;;             (org-agenda-time-grid nil)
    ;;             (org-agenda-start-on-weekday nil)
    ;;             (org-agenda-span 1)
    ;;             (org-agenda-show-all-dates nil)
    ;;             (org-scheduled-past-days 365)
    ;;             ;; Excludes today's scheduled items
    ;;             (org-scheduled-delay-days 1)
    ;;             (org-agenda-block-separator nil)
    ;;             (org-agenda-entry-types '(:scheduled))
    ;;             (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "ROUTINE"))
    ;;             (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
    ;;             (org-agenda-format-date "")))
    (agenda "" ((org-agenda-overriding-header "\nNext three days\n")
                (org-agenda-start-on-weekday nil)
                (org-agenda-start-day nil)
                (org-agenda-start-day "+1d")
                (org-agenda-span 3)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
    (agenda "" ((org-agenda-overriding-header "\nUpcoming deadlines (+14d)\n")
                (org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                ;; We don't want to replicate the previous section's
                ;; three days, so we start counting from the day after.
                (org-agenda-start-day "+4d")
                (org-agenda-span 14)
                (org-agenda-show-all-dates nil)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:deadline))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))))
  "Custom agenda for use in `org-agenda-custom-commands'.")

;;;;; agenda appointments

(defvar troi-org-agenda-after-edit-hook nil
  "Hook that runs after select Org commands.
To be used with `advice-add'.")

(defun troi-org--agenda-after-edit (&rest _)
  "Run `troi-org-agenda-after-edit-hook'."
  (run-hooks 'troi-org-agenda-after-edit-hook))

(defvar troi-org-after-deadline-or-schedule-hook nil
  "Hook that runs after `org--deadline-or-schedule'.
To be used with `advice-add'.")

(defvar troi-org--appt-agenda-commands
  '( org-agenda-archive org-agenda-deadline org-agenda-schedule
     org-agenda-todo org-archive-subtree)
  "List of commands that run `troi-org-agenda-after-edit-hook'.")

(dolist (fn troi-org--appt-agenda-commands)
  (advice-add fn :after #'troi-org--agenda-after-edit))

(defun troi-org--after-deadline-or-schedule (&rest _)
  "Run `troi-org-after-deadline-or-schedule-hook'."
  (run-hooks 'troi-org-after-deadline-or-schedule-hook))

(defun troi-org-org-agenda-to-appt ()
  "Make `org-agenda-to-appt' always refresh appointment list."
  (org-agenda-to-appt :refresh))

(dolist (hook '(org-capture-after-finalize-hook
                org-after-todo-state-change-hook
                org-agenda-after-show-hook
                troi-org-agenda-after-edit-hook))
  (add-hook hook #'troi-org-org-agenda-to-appt))

(declare-function org--deadline-or-schedule "org" (arg type time))

(advice-add #'org--deadline-or-schedule :after #'troi-org--after-deadline-or-schedule)

(add-hook 'troi-org-after-deadline-or-schedule-hook #'troi-org-org-agenda-to-appt)

;;;; org-export

(declare-function org-html-export-as-html "org")
(declare-function org-texinfo-export-to-info "org")

;;;###autoload
(defun troi-org-ox-html ()
  "Streamline HTML export."
  (interactive)
  (org-html-export-as-html nil nil nil t nil))

;;;###autoload
(defun troi-org-ox-texinfo ()
  "Streamline Info export."
  (interactive)
  (org-texinfo-export-to-info))

;;;; org-id

(declare-function org-id-add-location "org")
(declare-function org-with-point-at "org")
(declare-function org-entry-get "org")
(declare-function org-id-new "org")
(declare-function org-entry-put "org")

;; Original idea:
;; <https://writequit.org/articles/emacs-org-mode-generate-ids.html>.
(defun troi-org--id-get ()
  "Get the CUSTOM_ID of the current entry.
If the entry already has a CUSTOM_ID, return it as-is, else
create a new one."
  (let* ((pos (point))
         (id (org-entry-get pos "CUSTOM_ID")))
    (if (and id (stringp id) (string-match-p "\\S-" id))
        id
      (setq id (org-id-new "h"))
      (org-entry-put pos "CUSTOM_ID" id)
      id)))

(declare-function org-map-entries "org")

;;;###autoload
(defun troi-org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in current file."
  (interactive)
  (org-map-entries
   (lambda () (troi-org--id-get))))

;;;###autoload
(defun troi-org-id-headline ()
  "Add missing CUSTOM_ID to headline at point."
  (interactive)
  (troi-org--id-get))

;;;###autoload
(defun troi-org-get-dotemacs-link ()
  "Get URL to current heading in my dotemacs file."
  (declare (interactive-only t))
  (interactive)
  (if (and (derived-mode-p 'org-mode)
           (string-match-p "bad-emacs\\.org\\'" buffer-file-name))
      (if-let* ((id (org-entry-get (point) "CUSTOM_ID"))
                (url (concat "https://protesilaos.com/emacs/dotemacs#" id)))
          (progn
            (kill-new url)
            (message "Copied %s" (propertize url 'face 'success)))
        (error "No CUSTOM_ID for the current entry"))
    (user-error "You are not in the right file")))

(provide 'troi-org)
;;; troi-org.el ends here
#+end_src


** The =troi-pair.el= library
:PROPERTIES:
:CUSTOM_ID: h:0a3f076d-386d-47e6-8af9-f17d02d507cf
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-pair.el" :mkdirp yes
;;; troi-pair.el --- Insert character pair around symbol or region -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Insert character pair around symbol or region using minibuffer
;; completion.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup troi-pair nil
  "Insert character pair around symbol or region."
  :group 'editing)

(defcustom troi-pair-pairs
  '((?'  :description "Single quotes"           :pair (?' . ?'))
    (?\" :description "Double quotes"           :pair (?\" . ?\"))
    (?  :description "Single curly quotes"     :pair (? . ?))
    (?  :description "Double curly quotes"     :pair (? . ?))
    (?\> :description "Natural language quotes" :pair troi-pair-insert-natural-language-quotes)
    (?\( :description "Parentheses"             :pair (?\( . ?\)))
    (?{  :description "Curly brackets"          :pair (?{ . ?}))
    (?\[ :description "Square brackets"         :pair (?\[ . ?\]))
    (?\< :description "Angled brackets"         :pair (?\< . ?\>))
    (?@  :description "At signs"                :pair (?@ . ?@))
    (?=  :description "Equals signs"            :pair (?= . ?=))
    (?+  :description "Plus signs"              :pair (?+ . ?+))
    (?`  :description "Backticks"               :pair troi-pair-insert-backticks)
    (?~  :description "Tildes"                  :pair (?~ . ?~))
    (?*  :description "Asterisks"               :pair (?* . ?*))
    (?/  :description "Forward slashes"         :pair (?/ . ?/))
    (?_  :description "Underscores"             :pair (?_ . ?_)))
  "Alist of pairs for use with `troi-pair-insert'.
Each element in the list is a list whose `car' is a character and
the `cdr' is a plist with a `:description' and `:pair' keys.  The
`:description' is a string used to describe the character/pair in
interactive use, while `:pair' is a cons cell referencing the
opening and closing characters.

The value of `:pair' can also be the unquoted symbol of a
function.  The function is called with no arguments and must
return a cons cell of two characters.  Examples of such functions
are `troi-pair-insert-natural-language-quotes' and
`troi-pair-insert-backticks'"
  :type '(alist
          :key-type character
          :value-type (plist :options (((const :tag "Pair description" :description) string)
                                       ((const :tag "Characters" :pair)
                                        (choice (cons character character) function)))))
  :group 'troi-pair)

(defun troi-pair-insert-backticks ()
  "Return pair of backticks for `troi-pair-pairs'.
When the major mode is derived from `lisp-mode', return a pair of
backtick and single quote, else two backticks."
  (if (derived-mode-p 'lisp-mode 'lisp-data-mode)
      (cons ?` ?')
    (cons ?` ?`)))

(defun troi-pair-insert-natural-language-quotes ()
  "Return pair of quotes for `troi-pair-pairs', per natural language."
  ;; There are more here: <https://en.wikipedia.org/wiki/Quotation_mark>.
  ;; I cover the languages I might type in.
  (cond
   ((and current-input-method
         (string-match-p "\\(greek\\|french\\|spanish\\)" current-input-method))
    (cons ? ?))
   (t (cons ?\" ?\"))))

(defvar troi-pair--insert-history nil
  "Minibuffer history of `troi-pair--insert-prompt'.")

(defun troi-pair--annotate (character)
  "Annotate CHARACTER with its description in `troi-pair-pairs'."
  (when-let* ((char (if (characterp character) character (string-to-char character)))
              (plist (alist-get char troi-pair-pairs))
              (description (plist-get plist :description)))
    (format "  %s" description)))

(defun troi-pair--get-pair (character)
  "Get the pair of corresponding to CHARACTER."
  (when-let* ((char (if (characterp character) character (string-to-char character)))
              (plist (alist-get char troi-pair-pairs))
              (pair (plist-get plist :pair)))
    pair))

(defun troi-pair--insert-prompt ()
  "Prompt for pair among `troi-pair-pairs'."
  (let ((default (car troi-pair--insert-history))
        (candidates (mapcar (lambda (char) (char-to-string (car char))) troi-pair-pairs))
        (completion-extra-properties `(:annotation-function ,#'troi-pair--annotate)))
    (completing-read
     (format-prompt "Select pair" default)
     candidates nil :require-match
     nil 'troi-pair--insert-history default)))

(defun troi-pair--insert-bounds ()
  "Return boundaries of symbol at point or active region."
  (if (region-active-p)
      (cons (region-beginning) (region-end))
    (bounds-of-thing-at-point 'symbol)))

;;;###autoload
(defun troi-pair-insert (pair n)
  "Insert N number of PAIR around object at point.
PAIR is one among `troi-pair-pairs'.  The object at point is
either a symbol or the boundaries of the active region.  N is a
numeric prefix argument, defaulting to 1 if none is provided in
interactive use."
  (interactive
   (list
    (troi-pair--get-pair (troi-pair--insert-prompt))
    (prefix-numeric-value current-prefix-arg)))
  (let* ((bounds (troi-pair--insert-bounds))
         (beg (car bounds))
         (end (1+ (cdr bounds))) ; 1+ because we want the character after it
         (characters (if (functionp pair) (funcall pair) pair)))
    (dotimes (_ n)
      (save-excursion
        (goto-char beg)
        (insert (car characters))
        (goto-char end)
        (setq end (1+ end))
        (insert (cdr characters))))
    (goto-char (+ end (1- n)))))

;;;###autoload
(defun troi-pair-delete ()
  "Delete pair following or preceding point.
For Emacs version 28 or higher, the feedback's delay is
controlled by `delete-pair-blink-delay'."
  (interactive)
  (if (eq (point) (cdr (bounds-of-thing-at-point 'sexp)))
      (delete-pair -1)
    (delete-pair 1)))

(provide 'troi-pair)
;;; troi-pair.el ends here
#+end_src


** The =troi-prefix.el= library
:PROPERTIES:
:CUSTOM_ID: h:f860bd85-671e-477e-8233-23a8ba43e1c6
:END:

[ Watch: [[https://protesilaos.com/codelog/2024-01-29-emacs-prefix-map/][define prefix/leader key (nested key maps)]] (2024-01-29). ]

#+begin_src emacs-lisp :tangle "troi-lisp/troi-prefix.el" :mkdirp yes
;;; troi-prefix.el --- Prefix keymap for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Prefix keymap for my custom keymaps.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(declare-function troi-simple-kill-buffer-current "troi-simple" (&optional arg))
(declare-function troi-simple-rename-file-and-buffer "troi-simple" (name))
(declare-function troi-simple-buffers-major-mode "troi-simple")
(declare-function troi-simple-buffers-vc-root "troi-simple")
(declare-function beframe-buffer-menu "beframe" (&optional frame &key sort))

(defvar-keymap troi-prefix-buffer-map
  :doc "Prefix keymap for buffers."
  :name "Buffer"
  :prefix 'troi-prefix-buffer
  "m" #'beframe-buffer-menu
  "b" #'switch-to-buffer
  "B" #'troi-simple-buffers-major-mode
  "c" #'clone-indirect-buffer-other-window
  "f" #'fit-window-to-buffer
  "k" #'troi-simple-kill-buffer-current
  "g" #'revert-buffer-quick
  "r" #'troi-simple-rename-file-and-buffer
  "n" #'next-buffer
  "p" #'previous-buffer
  "v" #'troi-simple-buffers-vc-root)

(defvar-keymap troi-prefix-file-map
  :doc "Prefix keymaps for files."
  :name "File"
  :prefix 'troi-prefix-file
  "f" #'find-file
  "F" #'find-file-other-window
  "b" #'bookmark-jump
  "d" #'dired
  "l" #'find-library
  "m" #'man)

(defvar-keymap troi-prefix-insert-map
  :doc "Prefix keymap for character insertion."
  :name "Insert"
  :prefix 'troi-prefix-insert
  "i" #'insert-char
  "e" #'emoji-search
  "q" #'quoted-insert
  "s" #'emoji-search
  "l" #'emoji-list)

(declare-function logos-focus-mode "logos")
(declare-function keycast-mode-line-mode "keycast")
(declare-function rainbow-mode "rainbow")
(declare-function spacious-padding-mode "spacious-padding")

(defvar-keymap troi-prefix-mode-map
  :doc "Prefix keymap for minor mode toggles."
  :name "Toggle"
  :prefix 'troi-prefix-mode
  "f" #'flymake-mode
  "h" #'hl-line-mode
  "k" #'keycast-mode-line-mode
  "l" #'logos-focus-mode
  "m" #'menu-bar-mode
  "n" #'display-line-numbers-mode
  "t" #'toggle-truncate-lines
  "s" #'spacious-padding-mode
  "r" #'rainbow-mode
  "v" #'variable-pitch-mode)

(defvar-keymap troi-prefix-window-map
  :doc "Prefix keymap for windows."
  :name "Window"
  :prefix 'troi-prefix-window
  "u" #'winner-undo
  "r" #'winner-redo
  "b" #'balance-windows-area
  "d" #'toggle-window-dedicated
  "0" #'delete-window
  "1" #'delete-other-windows
  "!" #'delete-other-windows-vertically
  "2" #'split-window-below
  "@" #'split-root-window-below
  "3" #'split-window-right
  "#" #'split-root-window-right
  "o" #'other-window
  "^" #'tear-off-window
  "h" #'windmove-left
  "j" #'windmove-down
  "k" #'windmove-up
  "l" #'windmove-right
  "H" #'windmove-swap-states-left
  "J" #'windmove-swap-states-down
  "K" #'windmove-swap-states-up
  "L" #'windmove-swap-states-right)

(declare-function consult-find "consult" (&optional dir initial))
(declare-function consult-ripgrep "consult" (&optional dir initial))
(declare-function troi-search-grep "troi-search" (regexp &optional recursive))
(declare-function troi-search-grep-todo-keywords "troi-search" (&optional arg))
(declare-function troi-search-occur-browse-url "troi-search")
(declare-function troi-search-occur-outline "troi-search" (&optional arg))
(declare-function troi-simple-flush-and-diff "troi-simple" (regexp beg end))

(defvar-keymap troi-prefix-search-map
  :doc "Prefix keymap for search (and replace) commands."
  :name "Search"
  :prefix 'troi-prefix-search
  "f" #'consult-find
  "d" #'troi-simple-flush-and-diff
  "g" #'troi-search-grep
  "o" #'troi-search-occur-outline
  "r" #'consult-ripgrep
  "t" #'troi-search-grep-todo-keywords
  "u" #'troi-search-occur-browse-url)

(declare-function troi-simple-transpose-chars "troi-simple")
(declare-function troi-simple-transpose-lines "troi-simple" (arg))
(declare-function troi-simple-transpose-paragraphs "troi-simple" (arg))
(declare-function troi-simple-transpose-sentences "troi-simple" (arg))
(declare-function troi-simple-transpose-words "troi-simple" (arg))
(declare-function troi-simple-transpose-sexps "troi-simple" (arg))

(defvar-keymap troi-prefix-transpose-map
  :doc "Prefix keymap for object transposition."
  :name "Transpose"
  :prefix 'troi-prefix-transpose
  "c" #'troi-simple-transpose-chars
  "l" #'troi-simple-transpose-lines
  "p" #'troi-simple-transpose-paragraphs
  "s" #'troi-simple-transpose-sentences
  "w" #'troi-simple-transpose-words
  "x" #'troi-simple-transpose-sexps)

(defvar-keymap troi-prefix-expression-map
  :doc "Prefix keymap for s-expression motions."
  :name "S-EXP"
  :prefix 'troi-prefix-expression
  "a" #'beginning-of-defun
  "e" #'end-of-defun
  "f" #'forward-sexp
  "b" #'backward-sexp
  "n" #'forward-list
  "p" #'backward-list
  "d" #'up-list ; confusing name for what looks "out and down" to me
  "t" #'transpose-sexps
  "u" #'backward-up-list ; the actual "up"
  "k" #'kill-sexp
  "DEL" #'backward-kill-sexp)

(declare-function winner-undo "winner")
(declare-function winner-redo "winner")
(declare-function magit-status "magit" (&optional directory cache))
(declare-function troi-simple-other-windor-or-frame "troi-simple")

;; NOTE 2024-02-17: Some cons cells here have a symbol as a `cdr' and
;; some do not.  The former are those which define a prefix command
;; (per `define-prefix-command').  This is a symbol that references
;; the keymaps, thus making our binding an indirection: if we update
;; the key map, we automatically get the new key bindings.  Whereas
;; when we bind a key to the value of a variable, we have to update
;; the key map and then the binding for changes to propagate.
(defvar-keymap troi-prefix-map
  :doc "Prefix keymap with multiple subkeymaps."
  :name "Prot Prefix"
  :prefix 'troi-prefix
  "0" #'delete-window
  "1" #'delete-other-windows
  "!" #'delete-other-windows-vertically
  "^" #'tear-off-window
  "2" #'split-window-below
  "@" #'split-root-window-below
  "3" #'split-window-right
  "#" #'split-root-window-right
  "o" #'other-window
  "O" #'troi-simple-other-windor-or-frame
  "Q" #'save-buffers-kill-emacs
  "b" (cons "Buffer" 'troi-prefix-buffer)
  "c" #'world-clock
  "f" (cons "File" 'troi-prefix-file)
  "g" #'magit-status
  "h" (cons "Help" help-map)
  "i" (cons "Insert" 'troi-prefix-insert)
  "j" #'dired-jump
  "m" (cons "Minor modes" 'troi-prefix-mode)
  "n" (cons "Narrow" narrow-map)
  "p" (cons "Project" project-prefix-map)
  "r" (cons "Rect/Registers" ctl-x-r-map)
  "s" (cons "Search" 'troi-prefix-search)
  "t" (cons "Transpose" 'troi-prefix-transpose)
  "u" #'universal-argument
  "v" (cons "Version Control" 'vc-prefix-map)
  "w" (cons "Window" 'troi-prefix-window)
  "x" (cons "S-EXP" 'troi-prefix-expression))

;; ;; NOTE 2024-02-17: This is not needed anymore, because I bind a cons
;; ;; cell to the key.  The `car' of it is the description, which
;; ;; `which-key-mode' understands.
;;
;; (with-eval-after-load 'which-key
;;   (which-key-add-keymap-based-replacements troi-prefix-map
;;     "b" `("Buffer" . ,troi-prefix-buffer-map)
;;     "f" `("File" . ,troi-prefix-file-map)
;;     "h" `("Help" . ,help-map)
;;     "i" `("Insert" . ,troi-prefix-insert-map)
;;     "m" `("Mode" . ,troi-prefix-mode-map)
;;     "n" `("Narrow" . ,narrow-map)
;;     "p" `("Project" . ,project-prefix-map)
;;     "r" `("C-x r" . ,ctl-x-r-map)
;;     "s" `("Search" . ,troi-prefix-search-map)
;;     "t" `("Transpose" . ,troi-prefix-transpose-map)
;;     "v" `("C-x v" . ,vc-prefix-map)
;;     "w" `("Window" . ,troi-prefix-window-map)
;;     "x" `("S-EXP" . ,troi-prefix-expression-map)))

;; What follows is an older experiment with transient.  I like its
;; visuals, though find it hard to extend.  Keymaps are easier for me,
;; as I can add commands to one of the subkeymaps and they are readily
;; available without evaluating anything else.  Probably transient can
;; do this, though it is not obvious to me as to how.

;; (require 'transient)
;;
;; (transient-define-prefix troi-prefix-file nil
;;   "Transient with file commands."
;;   [["File or directory"
;;     ("f" "find-file" find-file)
;;     ("F" "find-file-other-window" find-file-other-window)]
;;    ["Directory only"
;;     ("d" "dired" dired)
;;     ("D" "dired-other-window" dired-other-window)]
;;    ["Documentation"
;;     ("l" "find-library" find-library)
;;     ("m" "man" man)]])
;;
;; (transient-define-prefix troi-prefix-buffer nil
;;   "Transient with buffer commands."
;;   [["Switch"
;;     ("b" "switch buffer" switch-to-buffer)
;;     ("B" "switch buf other window" switch-to-buffer-other-window)
;;     ("n" "next-buffer" next-buffer)
;;     ("p" "previous-buffer" previous-buffer)
;;     ("m" "buffer-menu" buffer-menu)
;;     ("q" "bury-buffer" bury-buffer)]
;;    ["Persist"
;;     ("c" "clone buffer" clone-indirect-buffer)
;;     ("C" "clone buf other window" clone-indirect-buffer-other-window)
;;     ("r" "rename-buffer" rename-buffer)
;;     ("R" "rename-uniquely" rename-uniquely)
;;     ("s" "save-buffer" save-buffer)
;;     ("w" "write-file" write-file)]
;;    ["Destroy"
;;     ("k" "kill-current-buffer" kill-current-buffer)
;;     ("K" "kill-buffer-and-window" kill-buffer-and-window)
;;     ("r" "revert-buffer" revert-buffer)]])
;;
;; (transient-define-prefix troi-prefix-search nil
;;   "Transient with search commands."
;;   [["Search"
;;     ("s" "isearch-forward" isearch-forward)
;;     ("S" "isearch-forward-regexp" isearch-forward-regexp)
;;     ("r" "isearch-backward" isearch-backward)
;;     ("R" "isearch-backward-regexp" isearch-backward-regexp)
;;     ("o" "occur" occur)]
;;    ["Edit"
;;     ("f" "flush-lines" flush-lines)
;;     ("k" "keep-lines" keep-lines)
;;     ("q" "query-replace" query-replace)
;;     ("Q" "query-replace-regexp" query-replace-regexp)]])
;;
;; (transient-define-prefix troi-prefix-window nil
;;   "Transient with window commands."
;;   [["Manage"
;;     ("b" "balance-windows" balance-windows)
;;     ("f" "fit-window-to-buffer" fit-window-to-buffer)
;;     ("t" "tear-off-window" tear-off-window)]
;;    ["Popup"
;;     ("c" "calc" calc)
;;     ("f" "list-faces-display" list-faces-display)
;;     ("r" "re-builder" re-builder)
;;     ("w" "world-clock" world-clock)]])
;;
;; ;; This is independent of the transient, though still useful.
;; (defvar-keymap troi-prefix-repeat-map
;;   :doc "Global prefix map for repeatable keybindings (per `repeat-mode')."
;;   :name "Repeat"
;;   :repeat t
;;   "n" #'next-buffer
;;   "p" #'previous-buffer
;;   "<down>" #'enlarge-window
;;   "<right>" #'enlarge-window-horizontally
;;   "<up>" #'shrink-window
;;   "<left>" #'shrink-window-horizontally)
;;
;; (transient-define-prefix troi-prefix-toggle nil
;;   "Transient with minor mode toggles."
;;   [["Interface"
;;     ("c" "context-menu-mode" context-menu-mode)
;;     ("m" "menu-bar-mode" menu-bar-mode)
;;     ("s" "scroll-bar-mode" scroll-bar-mode)
;;     ("C-t" "tool-bar-mode" tool-bar-mode)]
;;    ["Tools"
;;     ("d" "toggle-debug-on-error" toggle-debug-on-error)
;;     ("f" "follow-mode" follow-mode)
;;     ("l" "visual-line-mode" visual-line-mode)
;;     ("v" "variable-pitch-mode" variable-pitch-mode)
;;     ("t" "toggle-truncate-lines" toggle-truncate-lines)
;;     ("C-s" "window-toggle-side-windows" window-toggle-side-windows)]])
;;
;; (transient-define-prefix troi-prefix nil
;;   "Transient with common commands.
;; Commands that bring up transients have ... in their description."
;;   [["Common"
;;     ("b" "Buffer..." troi-prefix-buffer)
;;     ("f" "File..." troi-prefix-file)
;;     ("s" "Search..." troi-prefix-search)
;;     ("w" "Window..." troi-prefix-window)
;;     ("t" "Toggle..." troi-prefix-toggle)]
;;    ["Resize"
;;     ("   <up>" "Shrink vertically" shrink-window)
;;     (" <down>" "Enlarge vertically" enlarge-window)
;;     (" <left>" "Shrink horizontally" shrink-window-horizontally)
;;     ("<right>" "Enlarge horizontally" enlarge-window-horizontally)]
;;    ["Misc"
;;     ("e" "Emoji transient..." emoji-insert)
;;     ("E" "Emoji search" emoji-search)
;;     ("C-e" "Emoji buffer" emoji-list)
;;     ("RET" "Insert unicode" insert-char)
;;     ("\\" "toggle-input-method" toggle-input-method)]])

(provide 'troi-prefix)
;;; troi-prefix.el ends here
#+end_src


** The =troi-project.el= library
:PROPERTIES:
:CUSTOM_ID: h:654cfe49-f59d-4a0d-84ee-094ddce06848
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-project.el" :mkdirp yes
;;; troi-project.el --- Extensions for project.el -*- lexical-binding: t -*-

;; Copyright (C) 2024-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Extensions for project.el.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'project)
(require 'tab-bar)

;;;; Switch to a project root Dired outright

(defun troi-project--switch (directory &optional command)
  "Do the work of `project-switch-project' in the given DIRECTORY.
With optional COMMAND, run it in DIRECTORY."
  (let ((command (or (when (functionp command) command)
                     (if (symbolp project-switch-commands)
                         project-switch-commands
                       (project--switch-project-command))))
        (buffer (current-buffer)))
    (unwind-protect
        (progn
          (setq-local project-current-directory-override directory)
          (call-interactively command))
      (with-current-buffer buffer
        (kill-local-variable 'project-current-directory-override)))))

(defun troi-project--frame-names ()
  "Return a list of frame names."
  (mapcar #'car (make-frame-names-alist)))

;;;###autoload
(defun troi-project-switch (directory)
  "Switch to project DIRECTORY.
If DIRECTORY exists in a frame, select it.  Otherwise switch to
the project in DIRECTORY using `project-dired'."
  (interactive (list (funcall project-prompter)))
  (project--remember-dir directory)
  (let ((name (file-name-nondirectory (directory-file-name directory))))
    (if (member name (troi-project--frame-names))
        (select-frame-by-name name)
      (troi-project--switch directory 'project-dired))))

;;;; Produce a VC root log for the project

(defun troi-project-rename-vc-root-log (&rest _)
  "Rename the buffer of `vc-print-root-log' to mention the project."
  (when-let* ((root (vc-root-dir))
              ((consp project--list))
              ((member root (mapcar #'car project--list))))
    (rename-buffer (format "*vc-root-log: %s*" root))))

(advice-add #'vc-print-root-log :after #'troi-project-rename-vc-root-log)

;;;; One tab per project

;; NOTE 2024-01-15 07:07:52 +0200: I define the "in tab" functions as
;; a coding exercise.  I don't have a use for it, as I prefer to use
;; the approach of my `beframe' package instead.
(defun troi-project-in-tab--get-tab-names (&optional frame)
  "Return list of tab names associated with FRAME.
If FRAME is nil, use the current frame."
  (mapcar
   (lambda (tab)
     (alist-get 'name tab))
   (frame-parameter frame 'tabs)))

(defun troi-project-in-tab--create-tab (directory name)
  "Create new tab visiting DIRECTORY and named NAME."
  (tab-new)
  (find-file directory)
  (unwind-protect
      (troi-project--switch directory)
    (tab-rename name)
    ;; NOTE 2024-01-15 06:52 +0200: I am adding this because
    ;; `tab-rename' is not persistent for some reason. Probably a bug...
    (let* ((tabs (funcall tab-bar-tabs-function))
           (tab-to-rename (nth (tab-bar--current-tab-index) tabs)))
      (setf (alist-get 'explicit-name tab-to-rename) name))))

;;;###autoload
(defun troi-project-in-tab (directory)
  "Switch to project DIRECTORY in a tab.
If a tab is named after the non-directory component of DIRECTORY,
switch to it.  Otherwise, create a new tab and name it after the
non-directory component of DIRECTORY.

Use this as an alternative to `project-switch-project'."
  (interactive (list (funcall project-prompter)))
  (project--remember-dir directory)
  (let ((name (file-name-nondirectory (directory-file-name directory))))
    (if (member name (troi-project-in-tab--get-tab-names))
        (tab-switch name)
      (troi-project-in-tab--create-tab directory name))))

;;;; Set up a project root

;; I don't actually have a use-case for `troi-project-find-root',
;; but I wrote it once so I keep it here in case I ever need it.
;; Use it like this: (troi-project-find-root c-mode "Makefile")
(defmacro troi-project-find-root (mode file)
  "Define project root check for MODE given FILE.
MODE must be the symbol of the major mode, without a quote.  FILE
is a string."
  (let ((project-find-fn (intern (format "project-find-%s-root" mode)))
        (major-mode-fn (intern (format "troi-%s-project-find-function" mode)))
        (file-symbol (intern file)))
    `(progn
       (defun ,project-find-fn (dir)
         (when-let* ((root (locate-dominating-file dir ,file)))
           (cons ',file-symbol root)))

       (cl-defmethod project-root ((project (head ,file-symbol)))
         (cdr project))

       (defun ,(intern (format "troi-%s-project-find-function" mode)) ()
         (add-hook 'project-find-functions #',project-find-fn :depth :local))

       (add-hook ',(intern (format "%s-hook" mode)) #',major-mode-fn))))

(provide 'troi-project)
;;; troi-project.el ends here
#+end_src


** The =troi-scratch.el= library
:PROPERTIES:
:CUSTOM_ID: h:efebaec4-7273-4c5a-a4c4-9f99df0e46bb
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-scratch.el" :mkdirp yes
;;; troi-scratch.el --- Scratch buffers for editable major mode of choice -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Set up a scratch buffer for an editable major mode of choice.  The
;; idea is based on the `scratch.el' package by Ian Eure:
;; <https://github.com/ieure/scratch-el>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'troi-common)

(defgroup troi-scratch ()
  "Scratch buffers for editable major mode of choice."
  :group 'editing)

(defcustom troi-scratch-default-mode 'text-mode
  "Default major mode for `troi-scratch-scratch-buffer'."
  :type 'symbol
  :group 'troi-scratch)

(defun troi-scratch--scratch-list-modes ()
  "List known major modes."
  (let (symbols)
    (mapatoms
     (lambda (symbol)
       (when (and (functionp symbol)
                  (or (provided-mode-derived-p symbol 'text-mode)
                      (provided-mode-derived-p symbol 'prog-mode)))
         (push symbol symbols))))
    symbols))

(defun troi-scratch--insert-comment ()
  "Insert comment for major mode, if appropriate.
Insert a comment if `comment-start' is non-nil and the buffer is
empty."
  (when (and (troi-common-empty-buffer-p) comment-start)
    (insert (format "Scratch buffer for: %s\n\n" major-mode))
    (goto-char (point-min))
    (comment-region (line-beginning-position) (line-end-position))))

(defun troi-scratch--prepare-buffer (region &optional mode)
  "Add contents to scratch buffer and name it accordingly.

REGION is added to the contents to the new buffer.

Use the current buffer's major mode by default.  With optional
MODE use that major mode instead."
  (let ((major (or mode major-mode)))
    (with-current-buffer (pop-to-buffer (format "*%s scratch*" major))
      (funcall major)
      (troi-scratch--insert-comment)
      (goto-char (point-max))
      (unless (string-empty-p region)
        (when (troi-common-line-regexp-p 'non-empty)
          (insert "\n\n"))
        (insert region)))))

(defvar troi-scratch--major-mode-history nil
  "Minibuffer history of `troi-scratch--major-mode-prompt'.")

(defun troi-scratch--major-mode-prompt ()
  "Prompt for major mode and return the choice as a symbol."
  (intern
   (completing-read "Select major mode: "
                    (troi-scratch--scratch-list-modes)
                    nil
                    :require-match
                    nil
                    'troi-scratch--major-mode-history)))

(defun troi-scratch--capture-region ()
  "Capture active region, else return empty string."
  (if (region-active-p)
      (buffer-substring-no-properties (region-beginning) (region-end))
    ""))

;;;###autoload
(defun troi-scratch-buffer (&optional arg)
  "Produce a scratch buffer matching the current major mode.

With optional ARG as a prefix argument (\\[universal-argument]),
use `troi-scratch-default-mode'.

With ARG as a double prefix argument, prompt for a major mode
with completion.  Candidates are derivatives of `text-mode' or
`prog-mode'.

If region is active, copy its contents to the new scratch
buffer.

Buffers are named as *MAJOR-MODE scratch*.  If one already exists
for the given MAJOR-MODE, any text is appended to it."
  (interactive "P")
  (let ((region (troi-scratch--capture-region)))
    (pcase (prefix-numeric-value arg)
      (16 (troi-scratch--prepare-buffer region (troi-scratch--major-mode-prompt)))
      (4 (troi-scratch--prepare-buffer region troi-scratch-default-mode))
      (_ (troi-scratch--prepare-buffer region)))))

(provide 'troi-scratch)
;;; troi-scratch.el ends here
#+end_src


** The =troi-search.el= library
:PROPERTIES:
:CUSTOM_ID: h:0cab525d-fcbc-478c-b914-bbd69e33c635
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-search.el" :mkdirp yes
;;; troi-search.el --- Extensions to isearch, replace, grep for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my isearch.el, replace.el, and grep.el extensions, for
;; use in my Emacs setup: <https://protesilaos.com/emacs/dotemacs>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'isearch)
(require 'replace)
(require 'grep)
(require 'troi-common)

(defgroup troi-search ()
  "Setup for Isearch, Occur, and related."
  :group 'search)

;; NOTE 2021-09-16: Based on my git config for headings in diffs.  Read:
;; <https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/>.
(defcustom troi-search-outline-regexp-alist
  '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
    (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)"))
  "Alist of regular expressions per major mode.

For best results the key must be a symbol that corresponds to a
major mode.

To be used by `troi-search-occur-outline'."
  :type 'alist
  :group 'troi-search)

(defcustom troi-search-todo-keywords
  (concat "TODO\\|FIXME\\|NOTE\\|REVIEW\\|XXX\\|KLUDGE"
          "\\|HACK\\|WARN\\|WARNING\\|DEPRECATED\\|BUG")
  "Regexp with search to-do keywords."
  :type 'string
  :group 'troi-search)

;;;; Isearch

;;;###autoload
(defun troi-search-isearch-other-end ()
  "End current search in the opposite side of the match.
Particularly useful when the match does not fall within the
confines of word boundaries (e.g. multiple words)."
  (interactive)
  (isearch-done)
  (when isearch-other-end
    (goto-char isearch-other-end)))

;;;###autoload
(defun troi-search-isearch-abort-dwim ()
  "Delete failed `isearch' input, single char, or cancel search.

This is a modified variant of `isearch-abort' that allows us to
perform the following, based on the specifics of the case: (i)
delete the entirety of a non-matching part, when present; (ii)
delete a single character, when possible; (iii) exit current
search if no character is present and go back to point where the
search started."
  (interactive)
  (if (eq (length isearch-string) 0)
      (isearch-cancel)
    (isearch-del-char)
    (while (or (not isearch-success) isearch-error)
      (isearch-pop-state)))
  (isearch-update))

;;;###autoload
(defun troi-search-isearch-repeat-forward (&optional arg)
  "Move forward, keeping point at the beginning of the match.
Optionally move to ARGth match in the given direction."
  (interactive "p")
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end))
  (isearch-repeat-forward (or arg 1)))

;;;###autoload
(defun troi-search-isearch-repeat-backward (&optional arg)
  "Move backward, keeping point at the beginning of the match.
Optionally move to ARGth match in the given direction."
  (interactive "p")
  (when (and (not isearch-forward) isearch-other-end)
    (goto-char isearch-other-end))
  (isearch-repeat-backward (or arg 1)))

(defmacro troi-search-isearch-occurrence (name edge &optional doc)
  "Construct function for moving to `isearch' occurrence.
NAME is the name of the function.  EDGE is either the beginning
or the end of the buffer.  Optional DOC is the resulting
function's docstring."
  `(defun ,name (&optional arg)
     ,doc
     (interactive "p")
     (let ((x (or arg 1))
           (command (intern (format "isearch-%s-of-buffer" ,edge))))
       (isearch-forward-symbol-at-point)
       (funcall command x))))

(troi-search-isearch-occurrence
 troi-search-isearch-beginning-of-buffer
 "beginning"
 "Run `isearch-beginning-of-buffer' for the symbol at point.
With numeric ARG, move to ARGth occurrence counting from the
beginning of the buffer.")

(troi-search-isearch-occurrence
 troi-search-isearch-end-of-buffer
 "end"
 "Run `isearch-end-of-buffer' for the symbol at point.
With numeric ARG, move to ARGth occurrence counting from the
end of the buffer.")

;;;; Replace/Occur

(defvar troi-search-markup-replacements
  '((elisp-to-org-code "`\\(.*?\\)'" "~\\1~")
    (elisp-to-org-verbatim "`\\(.*?\\)'" "=\\1=")
    (org-to-elisp-quote "[=~]\\(.*?\\)[=~]" "`\\1'")
    (org-to-markdown-code "[=~]\\(.*?\\)[=~]" "`\\1`"))
  "Common markup replacement patterns.")

(defvar troi-search--replace-markup-history '()
  "Minibuffer history of `troi-search-replace-markup'.")

(defun troi-search--replace-markup-prompt ()
  "Prompt for `troi-search-replace-markup'."
  (let* ((def (nth 0 troi-search--replace-markup-history))
         (prompt (if def
                     (format "Replace markup TYPE [%s]: " def)
                   "Replace markup TYPE: ")))
    (intern
     (completing-read
      prompt
      ;; TODO 2022-05-01: maybe older Emacs versions need to explicitly
      ;; map through the car of each list?
      troi-search-markup-replacements
      nil t nil 'troi-search--replace-markup-history def))))

(defun troi-search-replace-markup (type)
  "Perform TYPE of markup replacement.
TYPE is the car of a list in `troi-search-markup-replacements'.

When used interactively, prompt for completion among the
available types.

When the region is active, only perform replacements within its
boundaries, else start from point to the end of the buffer."
  (interactive (list (troi-search--replace-markup-prompt)))
  (if-let* ((types troi-search-markup-replacements)
            ((memq type (mapcar #'car types)))
            (association (alist-get type types))
            (search (nth 0 association))
            (replace (nth 1 association)))
      (if (use-region-p)
          (replace-regexp-in-region search replace (region-beginning) (region-end))
        (while (re-search-forward search nil t)
          (replace-match replace)))
    (user-error "`%s' is not part of `troi-search-markup-replacements'" type)))

;; NOTE 2023-01-14: See my `substitute' package instead of the
;; following: <https://github.com/protesilaos/substitute>.

;; (defun troi-search-isearch-replace-symbol ()
;;   "Run `query-replace-regexp' for the symbol at point."
;;   (interactive)
;;   (isearch-forward-symbol-at-point)
;;   (isearch-query-replace-regexp))

(autoload 'goto-address-mode "goto-addr")

;;;###autoload
(defun troi-search-occur-urls ()
  "Produce buttonised list of all URLs in the current buffer."
  (interactive)
  (let ((buf-name (format "*links in <%s>*" (buffer-name))))
    (add-hook 'occur-hook #'goto-address-mode)
    (occur-1 troi-common-url-regexp "\\&" (list (current-buffer)) buf-name)
    (remove-hook 'occur-hook #'goto-address-mode)))

;;;###autoload
(defun troi-search-occur-browse-url ()
  "Point browser at a URL in the buffer using completion.
Which web browser to use depends on the value of the variable
`browse-url-browser-function'.

Also see `troi-search-occur-urls'."
  (interactive)
  (let ((matches nil))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp troi-common-url-regexp nil t)
        (push (match-string-no-properties 0) matches)))
    (funcall browse-url-browser-function
             (completing-read "Browse URL: " matches nil t))))

(defvar troi-search--occur-outline-hist '()
  "Minibuffer history of `troi-search-occur-outline'.")

(defun troi-search--occur-outline-prompt ()
  "Helper prompt for `troi-search-occur-outline'."
  (let* ((alist troi-search-outline-regexp-alist)
         (key (car (assoc major-mode alist)))
         (default (or key (nth 1 troi-search--occur-outline-hist))))
    (completing-read
     (format "Outline style [%s]: " default)
     (mapcar #'car alist)
     nil nil nil 'troi-search--occur-outline-hist default)))

(defvar-local troi-search--remap-cookie nil
  "Current local value of `troi-search--remap-match-face'.")

(defface troi-search-match '((t :inherit default))
  "Face intended to override `match' buffer-locally.")

(defun troi-search--remap-match-face (buf)
  "Remap `match' to `troi-search-match' in BUF."
  (with-current-buffer buf
    (setq troi-search--remap-cookie
          (face-remap-add-relative 'match 'troi-search-match))))

;;;###autoload
(defun troi-search-occur-outline (&optional arg)
  "Produce buffer outline from `troi-search-outline-regexp-alist'.

With optional prefix ARG (\\[universal-argument]), prompt for a
preset among the entries in `troi-search-outline-regexp-alist'.

ARG may also be a string (or regular expression) when called from
Lisp."
  (interactive "P")
  (let* ((regexp (when (and arg (not (stringp arg)))
                   (troi-search--occur-outline-prompt)))
         (rx (cond
              ((stringp arg)
               arg)
              ((and arg (string= major-mode regexp))
               (alist-get regexp troi-search-outline-regexp-alist))
              ((assoc major-mode troi-search-outline-regexp-alist)
               (alist-get major-mode troi-search-outline-regexp-alist))
              (t (user-error "Unknown outline style"))))
         (buf-name (format "*outline of <%s>*" (buffer-name))))
    (occur-1 rx nil (list (current-buffer)) buf-name)
    ;; Because we are producing an outline, we do not need to know what
    ;; the exact matches are.
    (troi-search--remap-match-face buf-name)
    (add-to-history 'troi-search--occur-outline-hist regexp)))

;;;###autoload
(defun troi-search-occur-todo-keywords (&optional context)
  "Produce Occur buffer with `troi-search-todo-keywords'.
With optional numeric prefix argument for CONTEXT, show as many
lines before and after each match.

When called from Lisp CONTEXT must satisfy `natnump'.  A faulty
value is read as 0.

Also see `troi-search-grep-todo-keywords'."
  (interactive "P")
  (let* ((case-fold-search nil)
         (num (cond
               (current-prefix-arg
	            (prefix-numeric-value current-prefix-arg))
               (t (if (natnump context) context 0))))
         (buf-name (format "*keywords in <%s>*" (buffer-name))))
    (occur-1 troi-search-todo-keywords num (list (current-buffer)) buf-name)))

;;;; Outline

(defun troi-search--get-outline ()
  "Return alist of outline outline-regexp and positions."
  (let* ((outline-regexp (format "^\\(?:%s\\)" (or (bound-and-true-p outline-regexp) "[*\^L]+")))
         (heading-alist (bound-and-true-p outline-heading-alist))
         (level-fun (or (bound-and-true-p outline-level)
                        (lambda () ;; as in the default from outline.el
                          (or (cdr (assoc (match-string 0) heading-alist))
                              (- (match-end 0) (match-beginning 0))))))
         candidates)
    (save-excursion
      (goto-char (point-min))
      (while (if (bound-and-true-p outline-search-function)
                 (funcall outline-search-function)
               (re-search-forward outline-regexp nil t))
        (push
         (format "%-5s %s"
                 (line-number-at-pos (point))
                 (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
         candidates)
        (goto-char (1+ (line-end-position)))))
    (if candidates
        (nreverse candidates)
      (user-error "No outline"))))

(defun troi-search--outline-prompt ()
  "Prompt for outline among headings retrieved by `troi-search--get-outline'."
  (completing-read
   "Go to outline: "
   (troi-common-completion-table-no-sort 'imenu (troi-search--get-outline))
   nil :require-match))

(defvar troi-search-outline-hook nil
  "Normal hook to run at the end of `troi-search-outline'.")

;;;###autoload
(defun troi-search-outline ()
  "Go to the line of the given outline using completion."
  (interactive)
  (when-let* ((selection (troi-search--outline-prompt))
              (line (string-to-number (car (split-string selection "\t")))))
    (goto-line line)
    (run-hooks 'troi-search-outline-hook)))

;;;; Grep

(defvar troi-search--grep-hist nil
  "Input history of grep searches.")

(defun troi-search-grep-prompt (&optional recursive)
  "Prompt for grep pattern.
With optional RECURSIVE, indicate that the search will be called
recursively."
  (read-regexp
   (concat (if recursive
               (propertize "Recursive" 'face 'warning)
             "Local")
           " grep for PATTERN: ")
   nil 'troi-search--grep-hist))

;;;###autoload
(defun troi-search-grep (regexp &optional recursive)
  "Run grep for REGEXP.
Search in the current directory using `lgrep'.  With optional
prefix argument (\\[universal-argument]) for RECURSIVE, run a
search starting from the current directory with `rgrep'."
  (interactive
   (list
    (troi-search-grep-prompt current-prefix-arg)
    current-prefix-arg))
  (unless grep-command
    (grep-compute-defaults))
  (if recursive
      (rgrep regexp "*" default-directory)
    (lgrep regexp "*" default-directory)))

;;;###autoload
(defun troi-search-grep-todo-keywords (&optional arg)
  "Use `troi-search-grep' to find `troi-search-todo-keywords'.

With optional prefix ARG use git-grep instead for the entire
repository (runs `troi-search-git-grep-todo-keywords').  If Git
is not available on the system, run `troi-search-grep'
recursively, starting from the current directory.

Also see `troi-search-occur-todo-keywords'."
  (interactive "P")
  (cond
   (arg
    (if (executable-find "git")
        (troi-search-git-grep-todo-keywords)
      (troi-search-grep troi-search-todo-keywords t)))
   (t
    (troi-search-grep troi-search-todo-keywords))))

;; NOTE 2022-01-30: We could use `project-find-regexp' but I prefer
;; grep's editable buffers.  Besides, where is the fun in that when we
;; can use `compilation-start' instead?
;;;###autoload
(defun troi-search-git-grep-todo-keywords ()
  "Use the git-grep mechanism for `troi-search-todo-keywords'."
  (interactive)
  (let ((regexp troi-search-todo-keywords)
        (default-directory (or (vc-root-dir)
                               (locate-dominating-file "." ".git")
                               default-directory)))
    (compilation-start
     (format "git --no-pager grep -n --color=auto -r -I -E -e %s" regexp)
     'grep-mode
     (lambda (mode) (format "*troi-search-git-%s for '%s'" mode regexp))
     t)))

(defun troi-search--add-revert-function (buffer mode fn regexp)
  "Append `revert-buffer-function' for FN with REGEXP to MODE BUFFER variables.
See `troi-search-find-grep-buffer' (or related) for the kind of
BUFFER this works with."
  (with-current-buffer buffer
    (setq-local revert-buffer-function
                (lambda (_ignore-auto _noconfirm)
                  (funcall fn regexp))
                ;; FIXME 2023-04-04: The `compile-command' does not
                ;; feel right here.  We do it because in grep-mode the
                ;; g key runs `recompile' which falls back to the
                ;; `compile-command'.  We want it to do the same thing
                ;; as `revert-buffer'.
                compile-command `(funcall ',fn ,regexp))
    (let ((inhibit-read-only t))
      (goto-char (point-min))
      (when (re-search-forward (format "-*- mode: %s;" mode) (line-end-position) :no-error 1)
        (insert
         (format " revert-buffer-function: %S; compile-command %S;"
                 `(lambda (_ignore-auto _noconfirm)
                    (,fn ,regexp))
                 `(funcall ,fn ,regexp)))))))

(defun troi-search--start-compilation (args mode buffer command query)
  "Run compilation with ARGS for MODE in BUFFER given COMMAND running QUERY."
  (compilation-start
   args
   (intern (format "%s-mode" mode))
   (lambda (_mode) buffer)
   :highlight-regexp)
  (troi-search--add-revert-function buffer mode command query))

(defvar troi-search--find-grep-hist '()
  "Minibuffer history for `troi-search-find-grep-buffer' and related.")

(defmacro troi-search-make-search (command docstring prompt function mode)
  "Produce COMMAND with DOCSTRING given PROMPT, FUNCTION, and MODE."
  `(defun ,command (query)
     ,(format
       "%s.

Place the output in a buffer that runs `%s'.  Store the
invocation of this command with REGEXP in a buffer-local
variable.  When the buffer is written to a file, per
`write-file', the `revert-buffer' command (typically bound to
`g') can be used to re-run the search.  The buffer contains
information about the search results, including the exact command
line flags that were used, the time the results were produced,
and the number of matches.  All matching entries are buttonized
and function as links to the context they reference."
       docstring mode)
     (interactive
      (list
       (read-regexp ,prompt nil 'troi-search--find-grep-hist)))
     (let ((args (,function query))
           (buffer-name (format "*troi-search-find for '%s'*" query)))
       (troi-search--start-compilation args ,mode buffer-name ',command query))))

(defun troi-search--find-grep-args (regexp)
  "Return find args to produce grep results for REGEXP."
  (concat
   "find " default-directory
   " -not " (shell-quote-argument "(")
   " -path " (shell-quote-argument "*/.git*")
   " -prune " (shell-quote-argument ")")
   " -type f"
   " -exec grep -nHE --color=auto " regexp " "
   (shell-quote-argument "{}")
   " " (shell-quote-argument ";") " "))

;;;###autoload (autoload 'troi-search-find-grep-buffer "troi-search")
(troi-search-make-search
 troi-search-find-grep-buffer
 "Combine find with grep to produce a buffer for REGEXP matches"
 "Find files matching REGEXP and show a grep buffer: "
 troi-search--find-grep-args
 "grep")

(defun troi-search--find-grep-files-args (regexp)
  "Return find args to produce file listing with contents matching REGEXP."
  (concat
   "find " default-directory
   " -not " (shell-quote-argument "(")
   " -path " (shell-quote-argument "*/.git*")
   " -prune " (shell-quote-argument ")")
   " -type f"
   " -exec grep -qo --color=auto " regexp " "
   (shell-quote-argument "{}")
   " "
   (shell-quote-argument ";") " "
   "-ls"))

;;;###autoload (autoload 'troi-search-find-grep-files-buffer "troi-search")
(troi-search-make-search
 troi-search-find-grep-files-buffer
 "Combine find with grep to produce a buffer for files matching REGEXP"
 "Find files with contents matching REGEXP and show a file listing: "
 troi-search--find-grep-files-args
 "dired")

(defun troi-search--find-file-names-args (regexp)
  "Return find args to produce file listing with file names matching REGEXP."
  (concat
   "find " default-directory
   " -not " (shell-quote-argument "(")
   " -path " (shell-quote-argument "*/.git*")
   " -prune " (shell-quote-argument ")")
   " -type f"
   " -iname '*" regexp "*'"
   " -exec ls -AFhldvN --group-directories-first --time-style=long-iso --color=auto --hyperlink=never "
   (shell-quote-argument "{}")
   " "
   (shell-quote-argument ";")))

;;;###autoload (autoload 'troi-search-find-files-buffer "troi-search")
(troi-search-make-search
 troi-search-find-files-buffer
 "Use find to produce a buffer for file names matching REGEXP"
 "Find files with name matching REGEXP and show a file listing: "
 troi-search--find-file-names-args
 "dired")

;; (defun troi-search-find-grep-file (regexp)
;;   "Use find to produce list of files that include REGEXP."
;;   (interactive
;;    (list
;;     (read-regexp "Find and grep for REGEXP: " nil 'troi-search--find-grep-hist)))
;;   (let ((files (process-lines "find"
;;                               "-type" "f"
;;                               "-exec" "grep" "-nHE" "--color=auto" (format "'%s" regexp) " "
;;                               "-ls" " "
;;                               "{};")
;;                ))
;;     (find-file (completing-read "Find file: "files))))

(provide 'troi-search)
;;; troi-search.el ends here
#+end_src


** The =troi-shell.el= library
:PROPERTIES:
:CUSTOM_ID: h:32f6fe0f-23c4-44cc-97cc-3e5372bd484e
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-shell.el" :mkdirp yes
;;; troi-shell.el --- M-x shell extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my shell.el extensions, for use in my Emacs setup:
;; <https://protesilaos.com/emacs/dotemacs>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'shell)

;;;; Helper functions

(defun troi-shell--beginning-of-prompt-p ()
  "Return non-nil if point is at the beginning of a shell prompt."
  (if comint-use-prompt-regexp
      (looking-back comint-prompt-regexp (line-beginning-position))
    (eq (point) (comint-line-beginning-position))))

(defun troi-shell--insert-and-send (&rest args)
  "Insert and execute ARGS in the last shell prompt.
ARGS is a list of strings."
  (if (troi-shell--beginning-of-prompt-p)
      (progn
        (insert (mapconcat #'identity args " "))
        (comint-send-input))
    (user-error "Not at the beginning of prompt; won't insert: %s" args)))

(defun troi-shell--last-input ()
  "Return last input as a string."
  (buffer-substring-no-properties
   comint-last-input-start
   comint-last-input-end))

;;;; Input from shell command history using completion

(defun troi-shell--build-input-history ()
  "Return `comint-input-ring' as a list."
  (when (and (ring-p comint-input-ring)
	         (not (ring-empty-p comint-input-ring)))
    (let (history)
      ;; We have to build up a list ourselves from the ring vector.
      (dotimes (index (ring-length comint-input-ring))
        (push (ring-ref comint-input-ring index) history))
      (delete-dups history))))

(defvar troi-shell--input-history-completion-history nil
  "Minibuffer history of `troi-shell--input-history-prompt'.
Not to be confused with the shell input history, which is stored
in the `comint-input-ring' (see `troi-shell--build-input-history').")

(defun troi-shell--input-history-prompt ()
  "Prompt for completion against `troi-shell--build-input-history'."
  (let* ((history (troi-shell--build-input-history))
         (default (car history)))
    (completing-read
     (format-prompt "Insert input from history" default)
     history nil :require-match nil
     'troi-shell--input-history-completion-history
     default)))

;;;###autoload
(defun troi-shell-input-from-history ()
  "Insert command from shell input history.
Only account for the history Emacs knows about, ignoring
`comint-input-ring-file-name' (e.g. ~/.bash_history)."
  (declare (interactive-only t))
  (interactive)
  (troi-shell--insert-and-send
   (troi-shell--input-history-prompt)))

;;;; Directory navigation

;;;;; Directory tracking

(defvar troi-shell-cd-directories nil
  "List of accumulated `shell-last-dir'.")

(with-eval-after-load 'savehist
  (add-to-list 'savehist-additional-variables 'troi-shell-cd-directories))

(defun troi-shell-track-cd (&rest _)
  "Track shell input of cd commands.
Push `shell-last-dir' to `troi-shell-cd-directories'."
  (when-let* ((input (troi-shell--last-input))
              ((string-match-p "cd " input)))
    (push shell-last-dir troi-shell-cd-directories)))

(defun troi-shell-update-name-on-cd (&rest _)
  "Update the shell buffer name after a cd for use in `troi-shell'."
  (when-let* ((input (troi-shell--last-input))
              ((string-match-p "cd " input)))
    (rename-buffer (format "*troi-shell in %s*" default-directory) :make-unique)))

(defvar troi-shell--cd-history nil
  "Minibuffer history for `troi-shell-cd'.")

(defun troi-shell--cd-prompt ()
  "Prompt for a directory among `troi-shell-cd-directories'."
  (if-let* ((history troi-shell-cd-directories)
            (dirs (cons default-directory history))
            (def (if (listp dirs) (car dirs) shell-last-dir)))
      (completing-read
       (format-prompt "Select directory" def)
       dirs nil :require-match nil 'troi-shell--cd-history def)
    (user-error "No directories have been tracked")))

;;;###autoload
(defun troi-shell-cd ()
  "Switch to `troi-shell-cd-directories' using minibuffer completion."
  (declare (interactive-only t))
  (interactive)
  (troi-shell--insert-and-send
   "cd"
   (troi-shell--cd-prompt)))

;;;;; VC root directory

(defun troi-shell--get-vc-root-dir ()
  "Return `vc-root-dir' or root of present Git repository."
  (or (vc-root-dir)
      (locate-dominating-file "." ".git")))

;;;###autoload
(defun troi-shell-cd-vc-root-dir ()
  "Change into the `vc-root-dir'."
  (interactive)
  (if-let* ((root (troi-shell--get-vc-root-dir)))
      (troi-shell--insert-and-send "cd" root)
    (user-error "Cannot find the VC root of `%s'" default-directory)))

;;;; Bookmark support

;; NOTE 2023-08-18: I sent this to the Emacs maintainers as a patch
;; (bug#65039).  I received approval to proceed with the change, but I
;; did not do it because a user reported an issue with SSH (TRAMP).  I
;; do not have access to SSH and am not familiar with such workflows.
;; If/when that changes, I will try again.  In the meantime, this is
;; good code and it works for me.

;; Adapted from esh-mode.el
(declare-function bookmark-prop-get "bookmark" (bookmark prop))

(defun troi-shell-bookmark-name ()
  "Return name of bookmark based on currect directory."
  (format "troi-shell-%s"
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory default-directory)))))

(defvar sh-shell-file)

(defun troi-shell-bookmark-make-record ()
  "Create a bookmark for the current Shell buffer."
  `(,(troi-shell-bookmark-name)
    (location . ,default-directory)
    (shell-file-name . ,sh-shell-file)
    (handler . troi-shell-bookmark-jump)))

;;;###autoload
(defun troi-shell-bookmark-jump (bookmark)
  "Default BOOKMARK handler for Shell buffers."
  (let ((default-directory (bookmark-prop-get bookmark 'location))
        (explicit-shell-file-name (bookmark-prop-get bookmark 'shell-file-name)))
    (shell (get-buffer-create (car bookmark)))))

(put 'troi-shell-bookmark-jump 'bookmark-handler-type "Shell")

;; ;;;; Convert YouTube links to Invidious
;;
;; (defvar troi-shell-invidious-domains
;;   '("invidious.io.lol"
;;     "invidious.lunar.icu"
;;     "iv.nboeck.de"
;;     "vid.priv.au"
;;     "invidious.tiekoetter.com"
;;     "inv.in.projectsegfau.lt"
;;     "onion.tube"
;;     "yt.artemislena.eu"
;;     "invidious.no-logs.com"
;;     "yewtu.be"
;;     "invidious.projectsegfau.lt"
;;     "yt.oelrichsgarcia.de"
;;     "invidious.0011.lt"
;;     "inv.zzls.xyz"
;;     "inv.bp.projectsegfau.lt"
;;     "invidious.flokinet.to"
;;     "iv.ggtyler.dev"
;;     "invidious.slipfox.xyz"
;;     "vid.puffyan.us"
;;     "inv.pistasjis.net"
;;     "inv.citw.lgbt"
;;     "invidious.protokolla.fi"
;;     "inv.makerlab.tech"
;;     "inv.tux.pizza"
;;     "invidious.privacydev.net")
;;   "List of Invidious domains.")
;;
;; (defvar troi-shell-youtube-domains
;;   '("www.youtube.com"
;;     "youtu.be")
;;   "List of YouTube domains.")
;;
;; (defvar troi-shell-yt-invidious-domains
;;   (append troi-shell-youtube-domains
;;           troi-shell-invidious-domains)
;;   "List of YouTube and Invidious domains.")
;;
;; (defun troi-shell--get-random-invidious-instance ()
;;   "Return `random' index from `troi-shell-invidious-domains'."
;;   (nth
;;    (random (length troi-shell-invidious-domains))
;;    troi-shell-invidious-domains))
;;
;; ;;;###autoload
;; (defun troi-shell-invidious ()
;;   "Convert `troi-shell-yt-invidious-domains' into a random Invidious instance."
;;   (interactive)
;;   (save-excursion
;;     (goto-char (line-beginning-position))
;;     (while (re-search-forward (regexp-opt troi-shell-yt-invidious-domains) (line-end-position) :no-error)
;;       (replace-match (troi-shell--get-random-invidious-instance)))))

;;;; Built-in Emacs commands

;; ;; `comint-input-filter-functions'
;; (defun troi-shell--intercept-input (input)
;;   (when (string-match-p "man " input)
;;     (comint-interrupt-subjob)
;;     ;; TODO 2023-08-18: The idea is to interrupt the input, and split
;;     ;; it such that, say, "man echo" becomes (man "echo")
;;     ;;
;;     ;; (let ((proc (get-buffer-process (current-buffer)))
;; 	;;       (inhibit-read-only t)
;; 	;;       replacement)
;;     ;;   (save-excursion
;;     ;;     (let ((pmark (progn (goto-char (process-mark proc))
;; 	;; 		                (forward-line 0)
;; 	;; 		                (point-marker))))
;; 	;;       (delete-region comint-last-input-end pmark)
;; 	;;       (goto-char (process-mark proc))
;; 	;;       (setq replacement (concat "*** Called command externally ***\n"
;; 	;; 			                    (buffer-substring pmark (point))))
;; 	;;       (delete-region pmark (point))))
;;     ;;   (comint-output-filter proc replacement))
;;     ))
;;
;; (add-hook 'comint-input-filter-functions #'troi-shell--intercept-input)

;;;; General commands

(defun troi-shell--history-or-motion (history-fn motion-fn arg)
  "Call HISTORY-FN or MOTION-FN with ARG depending on where point is.
If `troi-shell--beginning-of-prompt-p' returns non-nil call
HISTORY-FN, else MOTION-FN."
  (let ((fn (if (or (troi-shell--beginning-of-prompt-p)
                    (eq last-command 'comint-next-input)
                    (eq last-command 'comint-previous-input))
                history-fn
              motion-fn)))
    (funcall-interactively fn arg)
    (setq this-command fn)))

;;;###autoload
(defun troi-shell-up-dwim (arg)
  "Return previous ARGth history input or go ARGth lines up.
If point is at the beginning of a shell prompt, return previous
input, otherwise perform buffer motion."
  (interactive "^p")
  (troi-shell--history-or-motion 'comint-previous-input 'previous-line arg))

;;;###autoload
(defun troi-shell-down-dwim (arg)
  "Return next ARGth history input or or go ARGth lines down.
If point is at the beginning of a shell prompt, return previous
input, otherwise perform buffer motion."
  (interactive "^p")
  (troi-shell--history-or-motion 'comint-next-input 'next-line arg))

;;;###autoload
(defun troi-shell ()
  "Like `shell' but always start a new shell.
Name the shell buffer after the `default-directory'.  If the name of
that buffer already exists, then reuse it."
  (interactive)
  (with-current-buffer (shell (format "*troi-shell in %s*" default-directory))
    (add-hook 'comint-output-filter-functions #'troi-shell-update-name-on-cd nil :local)))

;;;; Minor mode setup

(defvar-keymap troi-shell-mode-map
  :doc "Key map for `troi-shell-mode'."
  "<up>" #'troi-shell-up-dwim
  "<down>" #'troi-shell-down-dwim
  "C-c C-d" #'troi-shell-cd
  ;; "C-c C-i" #'troi-shell-invidious
  "C-c C-j" #'troi-shell-input-from-history
  "C-c C-." #'troi-shell-cd-vc-root-dir
  "C-c C-r" #'troi-shell-cd-vc-root-dir)

(define-minor-mode troi-shell-mode
  "Provide extra functionality for the Emacs `shell'.
Add a bookmark handler for shell buffer and activate the
`troi-shell-mode-map':
\\{troi-shell-mode-map}"
  :init-value nil
  :global nil
  (if troi-shell-mode
      (progn
        (add-hook 'comint-output-filter-functions #'troi-shell-track-cd nil :local)
        (setq-local bookmark-make-record-function #'troi-shell-bookmark-make-record))
    (remove-hook 'comint-output-filter-functions #'troi-shell-track-cd :local)
    (setq-local bookmark-make-record-function nil)))

(provide 'troi-shell)
;;; troi-shell.el ends here
#+end_src


** The =troi-simple.el= library
:PROPERTIES:
:CUSTOM_ID: h:5f78e837-0d27-4390-bd9a-6d0bca57fa50
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-simple.el" :mkdirp yes
;;; troi-simple.el --- Common commands for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Common commands for my Emacs: <https://protesilaos.com/emacs/dotemacs/>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile
  (require 'cl-lib))
(require 'troi-common)

(defgroup troi-simple ()
  "Generic utilities for my dotemacs."
  :group 'editing)

(defcustom troi-simple-date-specifier "%F"
  "Date specifier for `format-time-string'.
Used by `troi-simple-inset-date'."
  :type 'string
  :group 'troi-simple)

(defcustom troi-simple-time-specifier "%R %z"
  "Time specifier for `format-time-string'.
Used by `troi-simple-inset-date'."
  :type 'string
  :group 'troi-simple)

;;; Commands

;;;; General commands

(defun troi-simple--mark (bounds)
  "Mark between BOUNDS as a cons cell of beginning and end positions."
  (push-mark (car bounds))
  (goto-char (cdr bounds))
  (activate-mark))

;;;###autoload
(defun troi-simple-mark-sexp ()
  "Mark symbolic expression at or near point.
Repeat to extend the region forward to the next symbolic
expression."
  (interactive)
  (if (and (region-active-p)
           (eq last-command this-command))
      (ignore-errors (forward-sexp 1))
    (when-let* ((thing (cond
                        ((thing-at-point 'url) 'url)
                        ((thing-at-point 'sexp) 'sexp)
                        ((thing-at-point 'string) 'string)
                        ((thing-at-point 'word) 'word))))
      (troi-simple--mark (bounds-of-thing-at-point thing)))))

;;;###autoload
(defun troi-simple-keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

;; DEPRECATED 2023-12-26: I have not used `troi-simple-describe-symbol'
;; since a very long time.  The idea is fine, but having a key binding
;; to provide a shortcut for C-h o RET is wasteful.

;; (autoload 'symbol-at-point "thingatpt")
;;
;; ;;;###autoload
;; (defun troi-simple-describe-symbol ()
;;   "Run `describe-symbol' for the `symbol-at-point'."
;;   (interactive)
;;   (describe-symbol (symbol-at-point)))

;; DEPRECATED 2023-12-26: The `troi-simple-goto-definition' is a good
;; idea but it needs more work.  Ultimately though, it is easier to
;; just produce a Help buffer and just go to the source from there by
;; typing 's'.

;; (declare-function help--symbol-completion-table "help-fns" (string pred action))
;;
;; ;;;###autoload
;; (defun troi-simple-goto-definition (symbol)
;;   "Prompt for SYMBOL and go to its source.
;; When called from Lisp, SYMBOL is a string."
;;   (interactive
;;    (list
;;     (completing-read "Go to source of SYMBOL: "
;;                      #'help--symbol-completion-table
;;                      nil :require-match)))
;;   (xref-find-definitions symbol))

;; DEPRECATED 2023-12-26: I have no need for these commands.  I was
;; just experimenting with a simple implementation.  It is not robust.
;; I can fix it, but I will still not use it, so I am deprecating it
;; instead.

;; (autoload 'number-at-point "thingatpt")
;;
;; (defun troi-simple--number-operate (number amount operation)
;;   "Perform OPERATION on NUMBER given AMOUNT and return the result.
;; OPERATION is the keyword `:increment' or `:decrement' to perform
;; `1+' or `1-', respectively."
;;   (when (and (numberp number) (numberp amount))
;;     (let ((fn (pcase operation
;;                 (:increment #'+)
;;                 (:decrement #'-)
;;                 (_ (user-error "Unknown operation `%s' for number `%s'" operation number)))))
;;       (funcall fn number amount))))
;;
;; (defun troi-simple--number-replace (number amount operation)
;;   "Perform OPERATION on NUMBER at point by AMOUNT."
;;   (when-let* ((bounds (bounds-of-thing-at-point 'number))
;;               (replacement (troi-simple--number-operate number amount operation)))
;;     (delete-region (car bounds) (cdr bounds))
;;     (save-excursion
;;       (insert (number-to-string replacement)))))
;;
;; ;;;###autoload
;; (defun troi-simple-number-increment (number amount)
;;   "Increment NUMBER by AMOUNT.
;; When called interactively, NUMBER is the one at point, while
;; AMOUNT is either 1 or that of a number prefix argument."
;;   (interactive
;;    (list
;;     (number-at-point)
;;     (prefix-numeric-value current-prefix-arg)))
;;   (troi-simple--number-replace number amount :increment))
;;
;; ;;;###autoload
;; (defun troi-simple-number-decrement (number amount)
;;   "Decrement NUMBER by AMOUNT.
;; When called interactively, NUMBER is the one at point, while
;; AMOUNT is either 1 or that of a number prefix argument."
;;   (interactive
;;    (list
;;     (number-at-point)
;;     (prefix-numeric-value current-prefix-arg)))
;;   (troi-simple--number-replace number amount :decrement))

;;;; Commands for lines

;;;###autoload
(defun troi-simple-new-line-below (n)
  "Create N empty lines below the current one.
When called interactively without a prefix numeric argument, N is
1."
  (interactive "p")
  (goto-char (line-end-position))
  (dotimes (_ n) (insert "\n")))

;;;###autoload
(defun troi-simple-new-line-above (n)
  "Create N empty lines above the current one.
When called interactively without a prefix numeric argument, N is
1."
  (interactive "p")
  (let ((point-min (point-min)))
    (if (or (bobp)
            (eq (point) point-min)
            (eq (line-number-at-pos point-min) 1))
        (progn
          (goto-char (line-beginning-position))
          (dotimes (_ n) (insert "\n"))
          (forward-line (- n)))
      (forward-line (- n))
      (troi-simple-new-line-below n))))

;;;###autoload
(defun troi-simple-copy-line ()
  "Copy the current line to the `kill-ring'."
  (interactive)
  (copy-region-as-kill (line-beginning-position) (line-end-position)))

(make-obsolete 'troi-simple-copy-line-or-region 'troi-simple-copy-line "2023-09-26")

;;;###autoload
(defun troi-simple-kill-ring-save (beg end)
  "Copy the current region or line.
When the region is active, use `kill-ring-save' between the BEG and END
positions.  Otherwise, copy the current line."
  (interactive "r")
  (if (region-active-p)
      (kill-ring-save beg end)
    (troi-simple-copy-line)))

(defun troi-simple--duplicate-buffer-substring (boundaries)
  "Duplicate buffer substring between BOUNDARIES.
BOUNDARIES is a cons cell representing buffer positions."
  (unless (consp boundaries)
    (error "`%s' is not a cons cell" boundaries))
  (let ((beg (car boundaries))
        (end (cdr boundaries)))
    (goto-char end)
    (newline)
    (insert (buffer-substring-no-properties beg end))))

;;;###autoload
(defun troi-simple-duplicate-line-or-region ()
  "Duplicate the current line or active region."
  (interactive)
  (unless mark-ring                  ; needed when entering a new buffer
    (push-mark (point) t nil))
  (troi-simple--duplicate-buffer-substring
   (if (region-active-p)
       (cons (region-beginning) (region-end))
     (cons (line-beginning-position) (line-end-position)))))

;;;###autoload
(defun troi-simple-yank-replace-line-or-region ()
  "Replace line or region with latest kill.
This command can then be followed by the standard
`yank-pop' (default is bound to \\[yank-pop])."
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-region (line-beginning-position) (line-end-position)))
  (yank))

;;;###autoload
(defun troi-simple-multi-line-below ()
  "Move half a screen below."
  (interactive)
  (forward-line (floor (window-height) 2))
  (setq this-command 'scroll-up-command))

;;;###autoload
(defun troi-simple-multi-line-above ()
  "Move half a screen above."
  (interactive)
  (forward-line (- (floor (window-height) 2)))
  (setq this-command 'scroll-down-command))

;;;###autoload
(defun troi-simple-kill-line-backward ()
  "Kill from point to the beginning of the line."
  (interactive)
  (kill-line 0))

;;;###autoload
(define-minor-mode troi-simple-auto-fill-visual-line-mode
  "Enable `visual-line-mode' and disable `auto-fill-mode' in the current buffer."
  :global nil
  (if troi-simple-auto-fill-visual-line-mode
      (progn
        (auto-fill-mode -1)
        (visual-line-mode 1))
    (auto-fill-mode 1)
    (visual-line-mode -1)))

;;;; Commands for text insertion or manipulation

;;;###autoload
(defun troi-simple-insert-date (&optional arg)
  "Insert the current date as `troi-simple-date-specifier'.

With optional prefix ARG (\\[universal-argument]) also append the
current time understood as `troi-simple-time-specifier'.

When region is active, delete the highlighted text and replace it
with the specified date."
  (interactive "P")
  (let* ((date troi-simple-date-specifier)
         (time troi-simple-time-specifier)
         (format (if arg (format "%s %s" date time) date)))
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (insert (format-time-string format))))

(defun troi-simple--pos-url-on-line (char)
  "Return position of `troi-common-url-regexp' at CHAR."
  (when (integer-or-marker-p char)
    (save-excursion
      (goto-char char)
      (re-search-forward troi-common-url-regexp (line-end-position) :noerror))))

;;;###autoload
(defun troi-simple-escape-url-line (char)
  "Escape all URLs or email addresses on the current line.
When called from Lisp CHAR is a buffer position to operate from
until the end of the line.  In interactive use, CHAR corresponds
to `line-beginning-position'."
  (interactive
   (list
    (if current-prefix-arg
        (re-search-forward
         troi-common-url-regexp
         (line-end-position) :no-error
         (prefix-numeric-value current-prefix-arg))
      (line-beginning-position))))
  (when-let* ((regexp-end (troi-simple--pos-url-on-line char)))
    (goto-char regexp-end)
    (unless (looking-at ">")
      (insert ">")
      (when (search-backward "\s" (line-beginning-position) :noerror)
        (forward-char 1))
      (insert "<"))
    (troi-simple-escape-url-line (1+ regexp-end)))
  (goto-char (line-end-position)))

;; Thanks to Bruno Boal for the original `troi-simple-escape-url-region'.
;; Check Bruno's Emacs config: <https://github.com/BBoal/emacs-config>.

;;;###autoload
(defun troi-simple-escape-url-region (&optional beg end)
  "Apply `troi-simple-escape-url-line' on region lines between BEG and END."
  (interactive
   (if (region-active-p)
       (list (region-beginning) (region-end))
     (error "There is no region!")))
  (let ((beg (min beg end))
        (end (max beg end)))
    (save-excursion
      (goto-char beg)
      (setq beg (line-beginning-position))
      (while (<= beg end)
        (troi-simple-escape-url-line beg)
        (beginning-of-line 2)
        (setq beg (point))))))

;;;###autoload
(defun troi-simple-escape-url-dwim ()
  "Escape URL on the current line or lines implied by the active region.
Call the commands `troi-simple-escape-url-line' and
`troi-simple-escape-url-region' ."
  (interactive)
  (if (region-active-p)
      (troi-simple-escape-url-region (region-beginning) (region-end))
    (troi-simple-escape-url-line (line-beginning-position))))

;;;###autoload
(defun troi-simple-zap-to-char-backward (char &optional arg)
  "Backward `zap-to-char' for CHAR.
Optional ARG is a numeric prefix to match ARGth occurance of
CHAR."
  (interactive
   (list
    (read-char-from-minibuffer "Zap to char: " nil 'read-char-history)
    (prefix-numeric-value current-prefix-arg)))
  (zap-to-char (- arg) char t))

(defvar troi-simple-flush-and-diff-history nil
  "Minibuffer history for `troi-simple-flush-and-diff'.")

;;;###autoload
(defun troi-simple-flush-and-diff (regexp beg end)
  "Call `flush-lines' for REGEXP and produce diff if file is modified.
When region is active, operate between the region boundaries
demarcated by BEG and END."
  (interactive
   (let ((regionp (region-active-p)))
     (list
      (read-regexp "Flush lines using REGEXP: " nil 'troi-simple-flush-and-diff-history)
      (and regionp (region-beginning))
      (and regionp (region-end)))))
  (flush-lines regexp (or beg (point-min)) (or end (point-max)) :no-message)
  (when (and (buffer-modified-p) buffer-file-name)
    (diff-buffer-with-file (current-buffer))))

;; FIXME 2023-09-28: The line prefix is problematic.  I plan to rewrite it.

;; (defcustom troi-simple-line-prefix-strings '(">" "+" "-")
;;   "List of strings used as line prefixes.
;; The command which serves as the point of entry is
;; `troi-simple-insert-line-prefix'."
;;   :type '(repeat string)
;;   :group 'troi-simple)
;;
;; (defun troi-simple--line-prefix-regexp (&optional string)
;;   "Format regular expression for `troi-simple--line-prefix-p'.
;; With optional STRING use it directly.  Else format the regexp by
;; concatenating `troi-simple-line-prefix-strings'."
;;   (if string
;;       (format "^%s " string)
;;     (format "^[%s] " (apply #'concat troi-simple-line-prefix-strings))))
;;
;; (defun troi-simple--line-prefix-p (&optional string)
;;   "Return non-nil if line beginning has an appropriate string prefix.
;; With optional STRING test that it is at the beginning of the line."
;;   (save-excursion
;;     (goto-char (line-beginning-position))
;;     (looking-at (troi-simple--line-prefix-regexp string))))
;;
;; (defun troi-simple--line-prefix-insert (string)
;;   "Insert STRING at the beginning of the line, followed by a space."
;;   (save-excursion
;;     (goto-char (line-beginning-position))
;;     (insert string)
;;     (insert " ")))
;;
;; (defun troi-simple--line-prefix-infer-string ()
;;   "Return line prefix string if it matches `troi-simple--line-prefix-p'."
;;   (when (troi-simple--line-prefix-p)
;;     (string-trim
;;      (buffer-substring-no-properties (match-beginning 0) (match-end 0)))))
;;
;; (defun troi-simple--line-prefix-toggle (string)
;;   "Insert or remove STRING at the beginning of the line."
;;   (if (troi-simple--line-prefix-p string)
;;       (delete-region (match-beginning 0) (match-end 0))
;;     (troi-simple--line-prefix-insert string)))
;;
;; (defvar troi-simple--line-prefix-history nil
;;   "Minibuffer history of `troi-simple--line-prefix-prompt'.")
;;
;; (defun troi-simple--line-prefix-prompt ()
;;   "Prompt for string to use as line prefix.
;; Provide `troi-simple-line-prefix-strings' as completion
;; candidates, though accept arbitrary input."
;;   (let ((default (car troi-simple--line-prefix-history)))
;;     (completing-read
;;      (format-prompt "Select line prefix" default)
;;      troi-simple-line-prefix-strings
;;      nil nil nil
;;      'troi-simple--line-prefix-history default)))
;;
;; (defun troi-simple-line-prefix-infer-or-prompt ()
;;   "Infer string for line prefix or prompt for one."
;;   (or (troi-simple--line-prefix-infer-string)
;;       (troi-simple--line-prefix-prompt)))
;;
;; ;;;###autoload
;; (defun troi-simple-insert-line-prefix-dwim (string)
;;   "Toggle presence of STRING at the beginning of the line.
;;
;; When called interactively try to infer STRING based on the line
;; prefix.  If one is found among `troi-simple-line-prefix-strings',
;; perform a removal outright.
;;
;; If no string can be inferred, prompt for STRING among
;; `troi-simple-line-prefix-strings'.  Accept arbitrary strings at
;; the prompt.
;;
;; When the region is active, toggle the presence of STRING for each
;; line in the region."
;;   (interactive (list (troi-simple-line-prefix-infer-or-prompt)))
;;   (if-let* ((region-p (region-active-p))
;;             (beg (region-beginning))
;;             (end (line-number-at-pos (region-end))))
;;       (progn
;;         (goto-char beg)
;;         (push-mark (point))
;;         (while (<= (line-number-at-pos (point)) end)
;;           (troi-simple--line-prefix-toggle string)
;;           (forward-line 1)))
;;     (troi-simple--line-prefix-toggle string)))

;;;; Commands for object transposition

;; The "move" functions all the way to `troi-simple-move-below-dwim'
;; are courtesy of Bruno Boal: <https://git.sr.ht/~bboal>.  With minor
;; tweaks by me.
(defun troi-simple--move-line (count dir)
  "Move line or region COUNTth times in DIR direction."
  (let* ((start (pos-bol))
         (end (pos-eol))
         diff-eol-point
         diff-eol-mark)
    (when-let* (((use-region-p))
                (pos (point))
                (mrk (mark))
                (line-diff-mark-point (1+ (- (line-number-at-pos mrk)
                                             (line-number-at-pos pos)))))
      (if (> pos mrk)
          (setq start (pos-bol line-diff-mark-point)) ; pos-bol of where the mark is
        (setq end (pos-eol line-diff-mark-point)))    ; pos-eol of the line where the mark is
      (setq diff-eol-mark (1+ (- end mrk))))          ; 1+ to get the \n
    ;; this is valid for region or a single line
    (setq diff-eol-point (1+ (- end (point))))
    (let* ((max (point-max))
           (end (1+ end))
           (end (if (> end max) max end))
           (deactivate-mark)
           (lines (delete-and-extract-region start end)))
      (forward-line (* count dir))
      ;; Handle the special case when there isn't a newline as the eob.
      (when (and (eq (point) max)
                 (/= (current-column) 0))
        (insert "\n"))
      (insert lines)
      ;; if user provided a region
      (when diff-eol-mark
        (set-mark (- (point) diff-eol-mark)))
      ;; either way go to same point location reference initial motion
      (goto-char (- (point) diff-eol-point)))))

(defun troi-simple--move-line-user-error (boundary)
  "Return `user-error' with message accounting for BOUNDARY.
BOUNDARY is a buffer position, expected to be `point-min' or `point-max'."
  (when-let* ((bound (line-number-at-pos boundary))
              (scope (cond
                      ((and (use-region-p)
                            (or (= (line-number-at-pos (point)) bound)
                                (= (line-number-at-pos (mark)) bound)))
                       "region is ")
                      ((= (line-number-at-pos (point)) bound)
                       "")
                      (t nil))))
    (user-error (format "Warning: %salready in the last line!" scope))))

(defun troi-simple-move-above-dwim (arg)
  "Move line or region ARGth times up.
If ARG is nil, do it one time."
  (interactive "p")
  (unless (troi-simple--move-line-user-error (point-min))
    (troi-simple--move-line arg -1)))

(defun troi-simple-move-below-dwim (arg)
  "Move line or region ARGth times down.
If ARG is nil, do it one time."
  (interactive "p")
  (unless (troi-simple--move-line-user-error (point-max))
    (troi-simple--move-line arg 1)))

(defmacro troi-simple-define-transpose (scope)
  "Define transposition command for SCOPE.
SCOPE is the text object to operate on.  The command's name is
troi-simple-transpose-SCOPE."
  `(defun ,(intern (format "troi-simple-transpose-%s" scope)) (arg)
     ,(format "Transpose %s.
Transposition over an active region will swap the object at
the region beginning with the one at the region end." scope)
     (interactive "p")
     (let ((fn (intern (format "%s-%s" "transpose" ,scope))))
       (if (use-region-p)
           (funcall fn 0)
         (funcall fn arg)))))

;;;###autoload (autoload 'troi-simple-transpose-lines "troi-simple")
;;;###autoload (autoload 'troi-simple-transpose-paragraphs "troi-simple")
;;;###autoload (autoload 'troi-simple-transpose-sentences "troi-simple")
;;;###autoload (autoload 'troi-simple-transpose-sexps "troi-simple")
;;;###autoload (autoload 'troi-simple-transpose-words "troi-simple")
(troi-simple-define-transpose "lines")
(troi-simple-define-transpose "paragraphs")
(troi-simple-define-transpose "sentences")
(troi-simple-define-transpose "sexps")
(troi-simple-define-transpose "words")

;;;###autoload
(defun troi-simple-transpose-chars ()
  "Always transposes the two characters before point.
There is no dragging the character forward.  This is the
behaviour of `transpose-chars' when point is at the end of the
line."
  (interactive)
  (transpose-chars -1)
  (forward-char))

;;;; Commands for paragraphs

;;;###autoload
(defun troi-simple-unfill-region-or-paragraph (&optional beg end)
  "Unfill paragraph or, when active, the region.
Join all lines in region delimited by BEG and END, if active,
while respecting any empty lines (so multiple paragraphs are not
joined, just unfilled).  If no region is active, operate on the
paragraph.  The idea is to produce the opposite effect of both
`fill-paragraph' and `fill-region'."
  (interactive "r")
  (let ((fill-column most-positive-fixnum))
    (if (use-region-p)
        (fill-region beg end)
      (fill-paragraph))))

;;;; Commands for windows and pages

;;;###autoload
(defun troi-simple-other-window ()
  "Wrapper for `other-window' and `next-multiframe-window'.
If there is only one window and multiple frames, call
`next-multiframe-window'.  Otherwise, call `other-window'."
  (interactive)
  (if (and (one-window-p) (length> (frame-list) 1))
      (progn
        (call-interactively #'next-multiframe-window)
        (setq this-command #'next-multiframe-window))
    (call-interactively #'other-window)
    (setq this-command #'other-window)))

;;;###autoload
(defun troi-simple-narrow-visible-window ()
  "Narrow buffer to wisible window area.
Also check `troi-simple-narrow-dwim'."
  (interactive)
  (let* ((bounds (troi-common-window-bounds))
         (window-area (- (cdr bounds) (car bounds)))
         (buffer-area (- (point-max) (point-min))))
    (if (/= buffer-area window-area)
        (narrow-to-region (car bounds) (cdr bounds))
      (user-error "Buffer fits in the window; won't narrow"))))

;;;###autoload
(defun troi-simple-narrow-dwim ()
  "Do-what-I-mean narrowing.
If region is active, narrow the buffer to the region's
boundaries.

If pages are defined by virtue of `troi-common-page-p', narrow to
the current page boundaries.

If no region is active and no pages exist, narrow to the visible
portion of the window.

If narrowing is in effect, widen the view."
  (interactive)
  (unless mark-ring                  ; needed when entering a new buffer
    (push-mark (point) t nil))
  (cond
   ((and (use-region-p)
         (null (buffer-narrowed-p)))
    (narrow-to-region (region-beginning) (region-end)))
   ((troi-common-page-p)
    (narrow-to-page))
   ((null (buffer-narrowed-p))
    (troi-simple-narrow-visible-window))
   ((widen))))

(defun troi-simple--narrow-to-page (count &optional back)
  "Narrow to COUNTth page with optional BACK motion."
  (if back
      (narrow-to-page (or (- count) -1))
    (narrow-to-page (or (abs count) 1)))
  ;; Avoids the problem of skipping pages while cycling back and forth.
  (goto-char (point-min)))

;;;###autoload
(defun troi-simple-forward-page-dwim (&optional count)
  "Move to next or COUNTth page forward.
If buffer is narrowed to the page, keep the effect while
performing the motion.  Always move point to the beginning of the
narrowed page."
  (interactive "p")
  (if (buffer-narrowed-p)
      (troi-simple--narrow-to-page count)
    (forward-page count)
    (setq this-command 'forward-page)))

;;;###autoload
(defun troi-simple-backward-page-dwim (&optional count)
  "Move to previous or COUNTth page backward.
If buffer is narrowed to the page, keep the effect while
performing the motion.  Always move point to the beginning of the
narrowed page."
  (interactive "p")
  (if (buffer-narrowed-p)
      (troi-simple--narrow-to-page count t)
    (backward-page count)
    (setq this-command 'backward-page)))

;;;###autoload
(defun troi-simple-delete-page-delimiters (&optional beg end)
  "Delete lines with just page delimiters in the current buffer.
When region is active, only operate on the region between BEG and
END, representing the point and mark."
  (interactive "r")
  (let (b e)
    (if (use-region-p)
        (setq b beg
              e end)
      (setq b (point-min)
            e (point-max)))
    (widen)
    (flush-lines (format "%s$" page-delimiter) b e)
    (setq this-command 'flush-lines)))

;; NOTE 2023-06-18: The idea of narrowing to a defun in an indirect
;; buffer is still experimental.
(defun troi-simple-narrow--guess-defun-symbol ()
  "Try to return symbol of current defun as a string."
  (save-excursion
    (beginning-of-defun)
    (search-forward " ")
    (thing-at-point 'symbol :no-properties)))

;;;###autoload
(defun troi-simple-narrow-to-cloned-buffer ()
  "Narrow to defun in cloned buffer.
Name the buffer after the defun's symbol."
  (interactive)
  (clone-indirect-buffer-other-window
   (format "%s -- %s"
           (buffer-name)
           (troi-simple-narrow--guess-defun-symbol))
   :display)
  (narrow-to-defun))

;;;; Commands for buffers

(defun troi-simple--display-unsaved-buffers (buffers buffer-menu-name)
  "Produce buffer menu listing BUFFERS called BUFFER-MENU-NAME."
  (let ((old-buf (current-buffer))
        (buf (get-buffer-create buffer-menu-name)))
    (with-current-buffer buf
      (Buffer-menu-mode)
      (setq-local Buffer-menu-files-only nil
                  Buffer-menu-buffer-list buffers
                  Buffer-menu-filter-predicate nil)
      (list-buffers--refresh buffers old-buf)
      (tabulated-list-print))
    (display-buffer buf)))

(defun troi-simple--get-unsaved-buffers ()
  "Get list of unsaved buffers."
  (seq-filter
   (lambda (buffer)
     (and (buffer-file-name buffer)
          (buffer-modified-p buffer)))
   (buffer-list)))

;;;###autoload
(defun troi-simple-display-unsaved-buffers ()
  "Produce buffer menu listing unsaved file-visiting buffers."
  (interactive)
  (if-let* ((unsaved-buffers (troi-simple--get-unsaved-buffers)))
      (troi-simple--display-unsaved-buffers unsaved-buffers "*Unsaved buffers*")
    (message "No unsaved buffers")))

(defun troi-simple-display-unsaved-buffers-on-exit (&rest _)
  "Produce buffer menu listing unsaved file-visiting buffers.
Add this as :before advice to `save-buffers-kill-emacs'."
  (when-let* ((unsaved-buffers (troi-simple--get-unsaved-buffers)))
    (troi-simple--display-unsaved-buffers unsaved-buffers "*Unsaved buffers*")))

;;;###autoload
(defun troi-simple-copy-current-buffer-name ()
  "Add the current buffer's name to the `kill-ring'."
  (declare (interactive-only t))
  (interactive)
  (kill-new (buffer-name (current-buffer))))

;;;###autoload
(defun troi-simple-copy-current-buffer-file ()
  "Add the current buffer's file path to the `kill-ring'."
  (declare (interactive-only t))
  (interactive)
  (if buffer-file-name
      (kill-new buffer-file-name)
    (user-error "%s is not associated with a file" (buffer-name (current-buffer)))))

;;;###autoload
(defun troi-simple-kill-buffer (buffer)
  "Kill current BUFFER without confirmation.
When called interactively, prompt for BUFFER."
  (interactive (list (read-buffer "Select buffer: ")))
  (let ((kill-buffer-query-functions nil))
    (kill-buffer (or buffer (current-buffer)))))

;;;###autoload
(defun troi-simple-kill-buffer-current (&optional arg)
  "Kill current buffer.
With optional prefix ARG (\\[universal-argument]) delete the
buffer's window as well.  Kill the window regardless of ARG if it
satisfies `troi-common-window-small-p' and it has no previous
buffers in its history."
  (interactive "P")
  (let ((kill-buffer-query-functions nil))
    (if (or (and (troi-common-window-small-p)
                 (null (window-prev-buffers)))
            (and arg (not (one-window-p))))
        (kill-buffer-and-window)
      (kill-buffer))))

;;;###autoload
(defun troi-simple-rename-file-and-buffer (name)
  "Apply NAME to current file and rename its buffer.
Do not try to make a new directory or anything fancy."
  (interactive
   (list (read-string "Rename current file: " (buffer-file-name))))
  (let ((file (buffer-file-name)))
    (if (vc-registered file)
        (vc-rename-file file name)
      (rename-file file name))
    (set-visited-file-name name t t)))

(defun troi-simple--buffer-major-mode-prompt ()
  "Prompt of `troi-simple-buffers-major-mode'.
Limit list of buffers to those matching the current
`major-mode' or its derivatives."
  (let ((read-buffer-function nil)
        (current-major-mode major-mode))
    (read-buffer
     (format "Buffer for %s: " major-mode)
     nil
     :require-match
     (lambda (pair) ; pair is (name-string . buffer-object)
       (with-current-buffer (cdr pair)
         (derived-mode-p current-major-mode))))))

;;;###autoload
(defun troi-simple-buffers-major-mode ()
  "Select BUFFER matching the current one's major mode."
  (interactive)
  (switch-to-buffer (troi-simple--buffer-major-mode-prompt)))

(defun troi-simple--buffer-vc-root-prompt ()
  "Prompt of `troi-simple-buffers-vc-root'."
  (let ((root (or (vc-root-dir)
                  (locate-dominating-file "." ".git")))
        (read-buffer-function nil))
    (read-buffer
     (format "Buffers in %s: " root)
     nil t
     (lambda (pair) ; pair is (name-string . buffer-object)
       (with-current-buffer (cdr pair) (string-match-p root default-directory))))))

;;;###autoload
(defun troi-simple-buffers-vc-root ()
  "Select buffer matching the current one's VC root."
  (interactive)
  (switch-to-buffer (troi-simple--buffer-vc-root-prompt)))

;;;###autoload
(defun troi-simple-swap-window-buffers (counter)
  "Swap states of live buffers.
With two windows, transpose their buffers.  With more windows,
perform a clockwise rotation.  Do not alter the window layout.
Just move the buffers around.

With COUNTER as a prefix argument, do the rotation
counter-clockwise."
  (interactive "P")
  (when-let* ((winlist (if counter (reverse (window-list)) (window-list)))
              (wincount (count-windows))
              ((> wincount 1)))
    (dotimes (i (- wincount 1))
      (window-swap-states (elt winlist i) (elt winlist (+ i 1))))))

;;;; Commands for files

(cl-defmethod register--type ((_regval vector)) 'vector)

(cl-defmethod register-val-describe ((val vector) _verbose)
  (if-let* ((pos (aref val 2))
            (file (aref val 1)))
      (princ (format "%s at position %s" file pos))
    (princ "Garbage data")))

;;;###autoload
(defun troi-simple-file-to-register (register)
  "Store current location of file's point in REGISTER."
  (interactive (list (register-read-with-preview "File with point to register: ")))
  (set-register register (vector 'file-with-point (buffer-file-name) (point))))

(defvar troi-simple-file-to-register-jump-hook nil
  "Normal hook called after jumping to a file register.
See `troi-simple-file-to-register'.")

;;;###autoload
(cl-defmethod register-val-jump-to ((val vector) delete)
  "Handle how to jump to a location register.
This is like the default, but does not ask to visit a file: it does it
outright."
  (cond
   ((eq (aref val 0) 'file-with-point)
    (find-file (aref val 1))
    (goto-char (aref val 2))
    (run-hooks 'troi-simple-file-to-register-jump-hook))
   (t (cl-call-next-method val delete))))

;;;; Commands of a general nature

(autoload 'color-rgb-to-hex "color")
(autoload 'color-name-to-rgb "color")

(defun troi-simple-accessible-colors (variant)
  "Return list of accessible `defined-colors'.
VARIANT is either `dark' or `light'."
  (let ((variant-color (if (eq variant 'black) "#000000" "#ffffff")))
    (seq-filter
     (lambda (c)
       (let* ((rgb (color-name-to-rgb c))
              (r (nth 0 rgb))
              (g (nth 1 rgb))
              (b (nth 2 rgb))
              (hex (color-rgb-to-hex r g b 2)))
         (when (>= (troi-common-contrast variant-color hex) 4.5)
           c)))
     (defined-colors))))

(defun troi-simple--list-accessible-colors-prompt ()
  "Use `read-multiple-choice' to return white or black background."
  (intern
   (cadr
    (read-multiple-choice
     "Variant"
     '((?b "black" "Black background")
       (?w "white" "White background"))
     "Choose between white or black background."))))

;;;###autoload
(defun troi-simple-list-accessible-colors (variant)
  "Return buffer with list of accessible `defined-colors'.
VARIANT is either `dark' or `light'."
  (interactive (list (troi-simple--list-accessible-colors-prompt)))
  (list-colors-display (troi-simple-accessible-colors variant)))

(provide 'troi-simple)
;;; troi-simple.el ends here
#+end_src


** The =troi-spell.el= library
:PROPERTIES:
:CUSTOM_ID: h:551718b7-fb2d-4a4a-804e-3118001b96ec
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-spell.el" :mkdirp yes
;;; troi-spell.el --- Spelling-related extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my spelling-related extensions, for use in my Emacs
;; setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'ispell)

(defgroup troi-spell ()
  "Extensions for ispell and flyspell."
  :group 'ispell)

(defcustom troi-spell-dictionaries
  '(("EN English" . "en")
    ("EL " . "el")
    ("FR Franais" . "fr")
    ("ES Espanl" . "es"))
  "Alist of strings with descriptions and dictionary keys.
Used by `troi-spell-change-dictionary'."
  :type 'alist
  :group 'troi-spell)

(defvar troi-spell--dictionary-hist '()
  "Input history for `troi-spell-change-dictionary'.")

(defun troi-spell--dictionary-prompt ()
  "Helper prompt to select from `troi-spell-dictionaries'."
  (let ((def (car troi-spell--dictionary-hist)))
    (completing-read
     (format "Select dictionary [%s]: " def)
     (mapcar #'car troi-spell-dictionaries)
     nil t nil 'troi-spell--dictionary-hist def)))

;;;###autoload
(defun troi-spell-change-dictionary (dictionary)
  "Select a DICTIONARY from `troi-spell-dictionaries'."
  (interactive
   (list (troi-spell--dictionary-prompt)))
  (let* ((key (cdr (assoc dictionary troi-spell-dictionaries)))
         (desc (car (assoc dictionary troi-spell-dictionaries))))
    (ispell-change-dictionary key)
    (message "Switched dictionary to %s" (propertize desc 'face 'bold))))

;;;###autoload
(defun troi-spell-spell-dwim (beg end)
  "Spell check between BEG END, current word, or select a dictionary.

Use `flyspell-region' on the active region and deactivate the
mark.

With point over a word and no active region invoke `ispell-word'.

Else call `troi-spell-change-dictionary'."
  (interactive "r")
  (cond
   ((use-region-p)
    (flyspell-region beg end)
    (deactivate-mark))
   ((thing-at-point 'word)
    (call-interactively 'ispell-word))
   (t
    (call-interactively 'troi-spell-change-dictionary))))

(defun troi-spell-ispell-display-buffer (buffer)
  "Function to override `ispell-display-buffer' for BUFFER.
Use this as `advice-add' to override the aforementioned Ispell
function.  Then you can control the buffer's specifics via
`display-buffer-alist' (how it ought to be!)."
  (pop-to-buffer buffer)
  (set-window-point (get-buffer-window buffer) (point-min)))

(advice-add #'ispell-display-buffer :override #'troi-spell-ispell-display-buffer)

(provide 'troi-spell)
;;; troi-spell.el ends here
#+end_src


** The =troi-vertico.el= library
:PROPERTIES:
:CUSTOM_ID: h:3796a4c9-8659-4782-8aaa-3cf4e950927d
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-vertico.el" :mkdirp yes
;;; troi-vertico.el --- Custom Vertico extras -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'vertico)

(defvar troi-vertico-multiform-minimal
  '(unobtrusive
    (vertico-flat-format . ( :multiple  ""
                             :single    ""
                             :prompt    ""
                             :separator ""
                             :ellipsis  ""
                             :no-match  "")))
  "List of configurations for minimal Vertico multiform.
The minimal view is intended to be more private or less
revealing.  This is important when, for example, a prompt shows
names of people.  Of course, such a view also provides a minimal
style for general usage.

Toggle the vertical view with the `vertico-multiform-vertical'
command or use the commands `troi-vertico-private-next' and
`troi-vertico-private-previous', which toggle the vertical view
automatically.")

(defvar troi-vertico-multiform-maximal
  '((vertico-count . 10)
    (vertico-resize . t))
  "List of configurations for maximal Vertico multiform.")

(defun troi-vertico--match-directory (str)
  "Match directory delimiter in STR."
  (string-suffix-p "/" str))

;; From the Vertico documentation.
(defun troi-vertico-sort-directories-first (files)
  "Sort directories before FILES."
  (setq files (vertico-sort-alpha files))
  (nconc (seq-filter #'troi-vertico--match-directory files)
         (seq-remove #'troi-vertico--match-directory files)))

(defun troi-vertico-private-next ()
  "Like `vertico-next' but toggle vertical view if needed.
This is done to accommodate `troi-vertico-multiform-minimal'."
  (interactive)
  (if vertico-unobtrusive-mode
      (let ((vertico--index 0))
        (vertico-multiform-vertical)
        (vertico-next 1))
    (vertico-next 1)))

(defun troi-vertico-private-previous ()
  "Like `vertico-previous' but toggle vertical view if needed.
This is done to accommodate `troi-vertico-multiform-minimal'."
  (interactive)
  (if vertico-unobtrusive-mode
      (progn
        (vertico-multiform-vertical)
        (vertico-previous 1))
    (vertico-previous 1)))

(defun troi-vertico-private-complete ()
  "Expand contents and show remaining candidates, if needed.
This is done to accommodate `troi-vertico-multiform-minimal'."
  (interactive)
  (if (and vertico-unobtrusive-mode (> vertico--total 1))
      (progn
        (minibuffer-complete)
        (vertico-multiform-vertical))
    (vertico-insert)))

(provide 'troi-vertico)
;;; troi-vertico.el ends here
#+end_src


** The =troi-window.el= library
:PROPERTIES:
:CUSTOM_ID: h:35b8a0a5-c447-4301-a404-bc274596238d
:END:

#+begin_src emacs-lisp :tangle "troi-lisp/troi-window.el" :mkdirp yes
;;; troi-window.el --- Display-buffer and window-related extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2023-2024  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my window and display-buffer extensions, for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'troi-common)

(defvar troi-window-window-sizes
  '( :max-height (lambda () (floor (frame-height) 3))
     :min-height 10
     :max-width (lambda () (floor (frame-width) 4))
     :min-width 20)
  "Property list of maximum and minimum window sizes.
The property keys are `:max-height', `:min-height', `:max-width',
and `:min-width'.  They all accept a value of either a
number (integer or floating point) or a function.")

(defun troi-window--get-window-size (key)
  "Extract the value of KEY from `troi-window-window-sizes'."
  (when-let* ((value (plist-get troi-window-window-sizes key)))
    (cond
     ((functionp value)
      (funcall value))
     ((numberp value)
      value)
     (t
      (error "The value of `%s' is neither a number nor a function" key)))))

(defun troi-window-select-fit-size (window)
  "Select WINDOW and resize it.
The resize pertains to the maximum and minimum values for height
and width, per `troi-window-window-sizes'.

Use this as the `body-function' in a `display-buffer-alist' entry."
  (select-window window)
  (fit-window-to-buffer
   window
   (troi-window--get-window-size :max-height)
   (troi-window--get-window-size :min-height)
   (troi-window--get-window-size :max-width)
   (troi-window--get-window-size :min-width))
  ;; If we did not use `display-buffer-below-selected', then we must
  ;; be in a lateral window, which has more space.  Then we do not
  ;; want to dedicate the window to this buffer, because we will be
  ;; running out of space.
  (when (or (window-in-direction 'above) (window-in-direction 'below))
    (set-window-dedicated-p window t)))

(defun troi-window--get-display-buffer-below-or-pop ()
  "Return list of functions for `troi-window-display-buffer-below-or-pop'."
  (list
   #'display-buffer-reuse-mode-window
   (if (or (troi-common-window-small-p)
           (troi-common-three-or-more-windows-p))
       #'display-buffer-below-selected
     #'display-buffer-pop-up-window)))

(defun troi-window-display-buffer-below-or-pop (&rest args)
  "Display buffer below current window or pop a new window.
The criterion for choosing to display the buffer below the
current one is a non-nil return value for
`troi-common-window-small-p'.

Apply ARGS expected by the underlying `display-buffer' functions.

This as the action function in a `display-buffer-alist' entry."
  (let ((functions (troi-window--get-display-buffer-below-or-pop)))
    (catch 'success
      (dolist (fn functions)
        (when (apply fn args)
          (throw 'success fn))))))

(defun troi-window-shell-or-term-p (buffer &rest _)
  "Check if BUFFER is a shell or terminal.
This is a predicate function for `buffer-match-p', intended for
use in `display-buffer-alist'."
  (when (string-match-p "\\*.*\\(e?shell\\|v?term\\).*" (buffer-name (get-buffer buffer)))
    (with-current-buffer buffer
      ;; REVIEW 2022-07-14: Is this robust?
      (and (not (derived-mode-p 'message-mode 'text-mode))
           (derived-mode-p 'eshell-mode 'shell-mode 'comint-mode 'fundamental-mode)))))

(defun troi-window-remove-dedicated (&rest _)
  "Remove dedicated window parameter.
Use this as :after advice to `delete-other-windows' and
`delete-window'."
  (when (one-window-p :no-mini)
    (set-window-dedicated-p nil nil)))

(mapc
 (lambda (fn)
   (advice-add fn :after #'troi-window-remove-dedicated))
 '(delete-other-windows delete-window))

(defmacro troi-window-define-full-frame (name &rest args)
  "Define command to call ARGS in new frame with `display-buffer-full-frame' bound.
Name the function troi-window- followed by NAME.  If ARGS is nil,
call NAME as a function."
  (declare (indent 1))
  `(defun ,(intern (format "troi-window-%s" name)) ()
     ,(format "Call `troi-window-%s' in accordance with `troi-window-define-full-frame'." name)
     (interactive)
     (let ((display-buffer-alist '((".*" (display-buffer-full-frame)))))
       (with-selected-frame (make-frame)
         ,(if args
              `(progn ,@args)
            `(funcall ',name))
         (modify-frame-parameters nil '((buffer-list . nil)))))))

(defun troi-window--get-shell-buffers ()
  "Return list of `shell' buffers."
  (seq-filter
   (lambda (buffer)
     (with-current-buffer buffer
       (derived-mode-p 'shell-mode)))
   (buffer-list)))

(defun troi-window--get-new-shell-buffer ()
  "Return buffer name for `shell' buffers."
  (if-let* ((buffers (troi-window--get-shell-buffers))
            (buffers-length (length buffers))
            ((>= buffers-length 1)))
      (format "*shell*<%s>" (1+ buffers-length))
    "*shell*"))

;;;###autoload (autoload 'troi-window-shell "troi-window")
(troi-window-define-full-frame shell
  (let ((name (troi-window--get-new-shell-buffer)))
    (shell name)
    (set-frame-name name)
    (when-let* ((buffer (get-buffer name)))
      (with-current-buffer buffer
        (add-hook
         'delete-frame-functions
         (lambda (_)
           ;; FIXME 2023-09-09: Works for multiple frames (per
           ;; `make-frame-command'), but not if the buffer is in two
           ;; windows in the same frame.
           (unless (> (safe-length (get-buffer-window-list buffer nil t)) 1)
             (let ((kill-buffer-query-functions nil))
               (kill-buffer buffer))))
         nil
         :local)))))

;;;###autoload (autoload 'troi-window-coach "troi-window")
(troi-window-define-full-frame coach
  (let ((buffer (get-buffer-create "*scratch for coach*")))
    (with-current-buffer buffer
      (funcall initial-major-mode))
    (display-buffer buffer)
    (set-frame-name "Coach")))

;; REVIEW 2023-06-25: Does this merit a user option?  I don't think I
;; will ever set it to the left.  It feels awkward there.
(defun troi-window-scroll-bar-placement ()
  "Control the placement of scroll bars."
  (when scroll-bar-mode
    (setq default-frame-scroll-bars 'right)
    (set-scroll-bar-mode 'right)))

(add-hook 'scroll-bar-mode-hook #'troi-window-scroll-bar-placement)

(defun troi-window-no-minibuffer-scroll-bar (frame)
  "Remove the minibuffer scroll bars from FRAME."
  (set-window-scroll-bars (minibuffer-window frame) nil nil nil nil :persistent))

(add-hook 'after-make-frame-functions 'troi-window-no-minibuffer-scroll-bar)

;;;; Run commands in a popup frame (via emacsclient)

(defun troi-window-delete-popup-frame (&rest _)
  "Kill selected selected frame if it has parameter `troi-window-popup-frame'.
Use this function via a hook."
  (when (frame-parameter nil 'troi-window-popup-frame)
    (delete-frame)))

(defmacro troi-window-define-with-popup-frame (command)
  "Define function which calls COMMAND in a new frame.
Make the new frame have the `troi-window-popup-frame' parameter."
  `(defun ,(intern (format "troi-window-popup-%s" command)) ()
     ,(format "Run `%s' in a popup frame with `troi-window-popup-frame' parameter.
Also see `troi-window-delete-popup-frame'." command)
     (interactive)
     (let ((frame (make-frame '((troi-window-popup-frame . t)))))
       (select-frame frame)
       (switch-to-buffer " troi-window-hidden-buffer-for-popup-frame")
       (condition-case nil
           (call-interactively ',command)
         ((quit error user-error)
          (delete-frame frame))))))

(declare-function org-capture "org-capture" (&optional goto keys))
(defvar org-capture-after-finalize-hook)

;;;###autoload (autoload 'troi-window-popup-org-capture "troi-window")
(troi-window-define-with-popup-frame org-capture)

(declare-function tmr "tmr" (time &optional description acknowledgep))
(defvar tmr-timer-created-functions)

;;;###autoload (autoload 'troi-window-popup-tmr "troi-window")
(troi-window-define-with-popup-frame tmr)

(provide 'troi-window)
;;; troi-window.el ends here
#+end_src

